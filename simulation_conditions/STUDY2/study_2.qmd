---
title: "Study 2: Comparative Performance of Normal–Gaussian and Exponential–Gaussian Copula VAR Models Under Exponential Innovations"
format:
  pdf:
    toc: true
    toc_depth: 3
execute:
  warning: false
  message: false
---

```{r setup}
#| label: setup
#| echo: false
suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readr)
  library(ggplot2)
  library(stringr)
  library(knitr)
  library(RColorBrewer)

  # optional helpers used in some workstreams
  if (!requireNamespace("ggh4x", quietly = TRUE)) {
    message("Package 'ggh4x' not installed; proceeding without nested facets.")
  }
  if (!requireNamespace("patchwork", quietly = TRUE)) {
    message("Package 'patchwork' is recommended for arranging plots.")
  } else {
    library(patchwork)
  }
})

# ---- paths ----
DATA_DIR   <- file.path("data")
RES_DIR    <- file.path("results")
EXPORT_DIR <- file.path(RES_DIR, "exported_tables_s2")
dir.create(EXPORT_DIR, showWarnings = FALSE, recursive = TRUE)

# Study 2 pipelines sometimes write either sim_conditions.rds or sim_conditions_singlelevel.rds.
# We accept either to make the report portable across directory layouts.
.design_candidates <- c(
  file.path(DATA_DIR, "sim_conditions.rds"),
  file.path(DATA_DIR, "sim_conditions_singlelevel.rds")
)
.design_path <- .design_candidates[file.exists(.design_candidates)][1]

files <- list(
  cond   = file.path(RES_DIR, "summary_conditions.csv"),
  rep    = file.path(RES_DIR, "summary_replications.csv"),
  design = .design_path
)

if (is.na(files$design) || !all(file.exists(unlist(files)))) {
  stop(
    "Missing required input files. Expected:\n",
    " - ", files$rep, "\n",
    " - ", files$cond, "\n",
    " - ", paste(.design_candidates, collapse = " or "), "\n",
    "Run the Study 2 pipeline and the analysis script first."
  )
}
```

# 0. Summary

## 0.1 Computational Stability versus Statistical Inference

Both models exhibit excellent computational stability across all simulation conditions. The Normal–Gaussian (NG) model shows no post-warmup divergent transitions and max $\hat{R} \leq 1.01$ in all replications. The Exponential–Gaussian (EG) model is equally well-behaved, with zero divergent transitions and good convergence diagnostics. This is an improvement over the SG model under extremeCHI in Study 1, where divergences were frequent.

## 0.2 Model Performance Under Exponential Innovations

**Exponential–Gaussian (EG):** EG is (i) approximately unbiased for the VAR dynamics $\Phi$ and intercepts $\mu$, and (ii) well calibrated for dependence when $\rho$ is interpreted on the correct scale in mixed-direction cells (see Section 1.1 for the sign convention under mirroring). Empirical coverage is close to 0.95 in most conditions

**Normal–Gaussian (NG):** NG is computationally stable but exhibits attenuation in $|\rho|$ and corresponding under-coverage for $\rho$ under Exponential margins. This attenuation arises from PIT distortion (see Study 1, Section 6.1).

## 0.3 Insights

PIT distortion induced by marginal CDF misspecification is the dominant failure mechanism, consistent with findings from Study 1. When NG assumes Gaussian margins but the true innovations are Exponential, the probability integral transform yields non-uniform PITs, which attenuate the effective dependence seen by the Gaussian copula.

# 1. Introduction

This simulation study extends the analysis from Study 1 by comparing two Bayesian VAR(1) models under exponential innovations: a Normal–Gaussian (NG) model and an Exponential–Gaussian (EG) model. While Study 1 examined skew-normal and chi-squared innovations, this study focuses on exponential margins to assess whether correctly specifying the marginal distribution recovers the models parameters without bias.

## 1.1. Data Generating Process (DGP)

The DGP follows the same structure as Study 1:

$$
Y_t = \mu + \Phi Y_{t-1} + \varepsilon_t, \qquad t = 2, \ldots, T,
$$

with $\mu = \mathbf{0}$. Innovations $\varepsilon_t = (\varepsilon_{1t}, \varepsilon_{2t})$ have standardized Exponential margins (mean 0, variance 1), with optional mirroring to induce left-skewness, and are coupled through a Gaussian copula with correlation parameter $\rho$.

::: {.callout-note}
## Standardization of Exponential Innovations

A standard Exponential(1) random variable $X$ has $\mathbb{E}[X] = 1$ and $\text{Var}(X) = 1$. To standardize:

$$
Z = X - 1
$$

yields $\mathbb{E}[Z] = 0$ and $\text{Var}(Z) = 1$. Mirroring ($-Z$) produces left-skewed innovations. For the joint density via Gaussian copula, see Study 1, Section 1.1.
:::

::: {.callout-important}
## Copula Sign Under Mirroring

Left-skew Exponential margins are produced by mirroring standardized Exponential innovations (multiplying by $-1$). For a Gaussian copula, mirroring exactly one margin corresponds to the transformation $u \mapsto 1-u$ on the PIT scale. Since $\Phi^{-1}(1-u) = -\Phi^{-1}(u)$, this flips the sign of the latent Gaussian score and therefore maps

$$
\rho \;\mapsto\; -\rho.
$$

Accordingly, in mixed-direction settings (e.g., $+-$), the effective copula correlation associated with the observed marginals is

$$
\rho_{\mathrm{eff}} \;=\; s_1 s_2\,\rho,\qquad s_j\in\{+1,-1\},
$$

where $s_j=-1$ indicates a mirrored (left-skew) margin.
:::

## 1.2. Simulation Design

The study employs a factorial design crossing four factors.

```{r design_table}
#| label: design_table
#| echo: false

design_summary <- tibble(
  Factor = c(
    "DGP Level",
    "Time Series Length (T)",
    "Copula Correlation ($\\rho$)",
    "VAR Parameters ($\\Phi$)",
    "",
    "Skewness Direction"
  ),
  Levels = c(
    "Standardized Exponential",
    "50, 100, 200",
    "0.30, 0.50 (reported as input; evaluation uses $\\rho_{\\mathrm{eff}}$ in mixed-direction cells)",
    "**Set A**: $\\begin{pmatrix} 0.40 & 0.10 \\\\ 0.10 & 0.40 \\end{pmatrix}$",
    "**Set B**: $\\begin{pmatrix} 0.55 & 0.10 \\\\ 0.10 & 0.25 \\end{pmatrix}$",
    "`++` (both right), `--` (both left), `+-` (mixed)"
  )
)

kable(design_summary, caption = "Summary of the Simulation Design Factors.", escape = FALSE)
```

::: {.callout-caution}
## Mixed-Direction Symmetry

Only one mixed-direction case ($+-$) is included. For the asymmetric VAR set $B$, $+-$ and $-+$ are not equivalent under variable relabeling. See Study 1, Section 1.2 for discussion of this design choice.
:::

## 1.3. True Parameter Values

```{r true_params_table}
#| label: true_params_table
#| echo: false

true_params <- tibble(
  Parameter = c(
    "$\\mu_1, \\mu_2$",
    "$\\phi_{11}$ (Set A / Set B)",
    "$\\phi_{12} = \\phi_{21}$",
    "$\\phi_{22}$ (Set A / Set B)",
    "$\\rho$",
    "$\\sigma_1, \\sigma_2$ (NG model)",
    "$\\sigma_{\\mathrm{exp},1}, \\sigma_{\\mathrm{exp},2}$ (EG model)"
  ),
  `True Value` = c(
    "0, 0",
    "0.40 / 0.55",
    "0.10",
    "0.40 / 0.25",
    "0.30 or 0.50",
    "1.0, 1.0",
    "1.0, 1.0"
  ),
  Notes = c(
    "Innovations are mean-zero",
    "Diagonal AR coefficients",
    "Cross-effects (symmetric)",
    "Diagonal AR coefficients",
    "Copula correlation",
    "Innovations are unit-variance",
    "Scale parameter for standardized Exponential"
  )
)

kable(true_params, caption = "True Parameter Values Used in the Data Generating Process.", escape = FALSE)
```

::: {.callout-note}
## Bias Metric for Intercepts ($\mu$)

Because $\mu = 0$ in the DGP, "relative bias" is undefined. We report absolute bias for $\mu$ (i.e., $\widehat{\mu} - 0$), using the convention $\text{rel\_bias} = \text{bias}$ when $|\text{truth}|$ is near 0.
:::

## 1.4 Visual Check: Standardized Marginal Innovations (DGP)

```{r dgp_marginal_distributions, fig.width=10, fig.height=6}
#| label: dgp_marginal_distributions
#| echo: false

set.seed(1)
N_draw <- 200000
u <- runif(N_draw)

# Exp(rate=1) has mean=1, sd=1; standardized draw is (x-1)
x_raw <- qexp(u, rate = 1)
x_std_right <- x_raw - 1
x_std_left  <- -(x_raw - 1)

plot_df <- tibble(
  value = c(x_std_right, x_std_left),
  dist  = rep(c("Exponential (std. right)", "Exponential (std. mirrored)"), each = N_draw)
)

ggplot(plot_df, aes(x = value, fill = dist)) +
  geom_histogram(aes(y = after_stat(density)), bins = 200, alpha = 0.35, position = "identity") +
  geom_density(linewidth = 0.9, alpha = 0.8) +
  stat_function(fun = dnorm, linewidth = 0.7, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  facet_wrap(~ dist, scales = "free", ncol = 2) +
  theme_bw(base_size = 12) +
  labs(
    title = "Standardized Exponential innovations used in Study 2",
    x = "value",
    y = "density"
  ) +
  guides(fill = "none")
```

# 2. Data Loading and Preparation

```{r}
#| label: data_prep
#| echo: false

# ---- design grid ----
design_raw <- readRDS(files$design)

# harmonize DGP label column across pipelines
if (!"skew_level" %in% names(design_raw)) {
  if ("dgp_level" %in% names(design_raw)) {
    design_raw <- design_raw |> mutate(skew_level = as.character(dgp_level))
  } else {
    # if the design grid has no DGP label column, treat it as fixed Exponential
    design_raw <- design_raw |> mutate(skew_level = "Exponential")
  }
}

# harmonize rho name if needed
if (!"rho" %in% names(design_raw) && "copula_rho" %in% names(design_raw)) {
  design_raw <- design_raw |> mutate(rho = copula_rho)
}

required_cols <- c("condition_id", "skew_level", "direction", "T", "rho", "VARset")
missing_cols <- setdiff(required_cols, names(design_raw))
if (length(missing_cols) > 0) {
  stop(
    "Design grid is missing required columns: ", paste(missing_cols, collapse = ", "),
    "\nAvailable columns: ", paste(names(design_raw), collapse = ", ")
  )
}

design <- design_raw |>
  select(condition_id, skew_level, direction, T, rho, VARset)

# ---- summaries ----
cond_raw <- read_csv(files$cond, show_col_types = FALSE) |>
  left_join(design, by = "condition_id")

rep_raw <- read_csv(files$rep, show_col_types = FALSE) |>
  filter(!is.na(param)) |>
  left_join(design, by = "condition_id")

# keep only NG and EG
keep_models <- c("NG", "EG")
cond_raw <- cond_raw |> filter(model %in% keep_models)
rep_raw  <- rep_raw  |> filter(model %in% keep_models)

# parameter order for plotting
param_levels <- c(
  # EG marginal scales
  "sigma_exp[1]", "sigma_exp[2]",
  # NG marginal sds
  "sigma[1]", "sigma[2]",
  # core parameters
  "mu[1]", "mu[2]", "phi11", "phi12", "phi21", "phi22", "rho"
)

# apply factor levels and clear labels
prep_data <- function(df) {
  df |>
    mutate(
      param = factor(param, levels = param_levels),
      T = factor(T),
      skew_level = factor(skew_level, levels = sort(unique(skew_level))),
      direction = factor(direction, levels = c("++", "+-", "--")),
      rho_val = rho,
      VARset_val = VARset,
      rho = factor(rho, levels = sort(unique(rho))),
      VARset = factor(VARset, levels = sort(unique(VARset))),
      Model = factor(
        ifelse(model == "EG", "Exponential–Gaussian (EG)", "Normal–Gaussian (NG)"),
        levels = c("Normal–Gaussian (NG)", "Exponential–Gaussian (EG)")
      )
    )
}

rep_df <- prep_data(rep_raw)

# ---- rho_eff adjustment for mirrored margins (see callout) ----
# direction is a two-character string, with '-' indicating mirroring.
dir_chr <- as.character(rep_df$direction)
s1 <- ifelse(substr(dir_chr, 1, 1) %in% c("-", "−"), -1, 1)
s2 <- ifelse(substr(dir_chr, 2, 2) %in% c("-", "−"), -1, 1)

rep_df <- rep_df |>
  mutate(
    rho_truth = rho_val * (s1 * s2)
  )

# recompute truth/bias/coverage using rho_truth only for param=='rho'
eps <- 1e-8
rep_df <- rep_df |>
  mutate(
    truth_eff = if_else(param == "rho", rho_truth, truth),
    bias_eff = post_mean - truth_eff,
    rel_bias_eff = if_else(abs(truth_eff) < eps, bias_eff, bias_eff / abs(truth_eff)),
    cover95_eff = (l95 <= truth_eff) & (u95 >= truth_eff)
  )
```

## 2.1. MCMC Classification and Overview

We classify runs based on MCMC diagnostics ($\hat{R}$ and divergent transitions) using the same criteria as Study 1:

- **Clean:** $\hat{R} \leq 1.01$ and no post-warmup divergences.
- **Problematic:** $\hat{R} > 1.01$ or at least one divergence.
- **Failed/Error:** Non-OK status or missing diagnostics.

```{r mcmc_classification}
#| label: mcmc_classification
#| echo: false

RHAT_THRESHOLD <- 1.01

rep_df <- rep_df |>
  mutate(
    n_div_clean = if_else(is.na(n_div), 0L, as.integer(n_div)),
    mcmc_status = case_when(
      is.na(max_rhat) | status != "ok" ~ "Failed/Error",
      max_rhat > RHAT_THRESHOLD | n_div_clean > 0 ~ "Problematic",
      TRUE ~ "Clean"
    ),
    mcmc_status = factor(mcmc_status, levels = c("Clean", "Problematic", "Failed/Error"))
  )

mcmc_summary <- rep_df |>
  distinct(condition_id, rep_id, Model, mcmc_status, T, skew_level) |>
  group_by(Model, T, skew_level, mcmc_status) |>
  summarise(Count = n(), .groups = "drop")
```

```{r mcmc_status_plot, fig.height=5, fig.width=10}
#| label: mcmc_status_plot
#| echo: false

ggplot(mcmc_summary, aes(x = T, y = Count, fill = mcmc_status)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_grid(Model ~ skew_level) +
  labs(
    x = "Time series length (T)",
    y = "Number of replications",
    fill = "MCMC status",
    title = "MCMC convergence status by model (Study 2)"
  ) +
  theme_bw(base_size = 14) +
  scale_fill_manual(values = c("Clean" = "#4daf4a", "Problematic" = "#ff7f00", "Failed/Error" = "#e41a1c"))
```

**Interpretation:** Both NG and EG fits are uniformly Clean across the entire design, with zero post-warmup divergent transitions. This excellent computational behavior contrasts with the SG model under extremeCHI in Study 1, which exhibited frequent divergences. The absence of sampling difficulties here demonstrates that correctly specifying the marginal distribution (EG with Exponential margins) avoids the posterior geometry challenges that arose from model misspecification.

```{r mcmc_divergences_plot, fig.height=5, fig.width=10}
#| label: mcmc_divergences_plot
#| echo: false

div_dist_data <- rep_df |>
  filter(param == "rho") |>
  distinct(condition_id, rep_id, Model, T, skew_level, n_div_clean, mcmc_status) |>
  filter(mcmc_status != "Failed/Error")

# Only show boxplot if there's variation in divergences; otherwise show summary table
if (max(div_dist_data$n_div_clean, na.rm = TRUE) > 0) {
  ggplot(div_dist_data, aes(x = T, y = n_div_clean, fill = Model)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.6, position = position_dodge(width = 0.8)) +
    geom_point(size = 1.5, alpha = 0.4, position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8)) +
    facet_grid(Model ~ skew_level) +
    theme_bw(base_size = 14) +
    labs(
      title = "Distribution of post-warmup divergent transitions",
      y = "Count of divergences (n_div)",
      x = "Time series length (T)"
    )
} else {
  # All divergences are zero - show summary table
  div_summary <- div_dist_data |>
    group_by(Model, T) |>
    summarise(
      n_runs = n(),
      total_div = sum(n_div_clean),
      .groups = "drop"
    )
  kable(div_summary, 
        caption = "Divergence summary: All runs have zero post-warmup divergent transitions.",
        col.names = c("Model", "T", "N Runs", "Total Divergences"))
}
```

# 3. Helpers

```{r helpers}
#| label: helpers
#| echo: false

# standardized visualization settings
theme_standard <- theme_bw(base_size = 14) +
  theme(legend.position = "bottom")

# A more compact theme for many-facet simulation figures
theme_facet <- theme_bw(base_size = 11) +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal",
    legend.margin = margin(t = 2, r = 0, b = 0, l = 0, unit = "pt"),
    strip.text.x = element_text(size = 9),
    strip.text.y = element_text(size = 9),
    axis.text = element_text(size = 8),
    axis.title = element_text(size = 10),
    panel.spacing = grid::unit(0.7, "lines")
  )

# Compact labellers to avoid unreadable facet strips
lab_short <- labeller(
  direction = function(x) x,
  VARset = function(x) paste0("VAR ", x),
  rho = function(x) paste0("rho=", x),
  param = function(x) x
)

# Readable metric plot: facet by (direction x VARset), encode input rho by linetype
plot_metric_readable <- function(data,
                                  metric_col,
                                  ylab,
                                  title,
                                  params = NULL,
                                  use_free_y = FALSE,
                                  ylims = NULL) {
  df <- data |>
    filter(!is.na(.data[[metric_col]]))

  if (!is.null(params)) {
    df <- df |> filter(param %in% params)
  }

  if (nrow(df) == 0) {
    message("Skipping plot '", title, "' due to missing data.")
    return(NULL)
  }

  # If rho is available, use linetype to avoid exploding the facet grid.
  has_rho <- "rho" %in% names(df)

  if (has_rho) {
    p <- ggplot(
      df,
      aes(
        x = T,
        y = .data[[metric_col]],
        color = Model,
        linetype = rho,
        group = interaction(Model, rho)
      )
    )
  } else {
    p <- ggplot(
      df,
      aes(
        x = T,
        y = .data[[metric_col]],
        color = Model,
        group = Model
      )
    )
  }

  p <- p +
    geom_line(linewidth = 0.9) +
    geom_point(size = 2.2) +
    facet_grid(
      param ~ direction + VARset,
      labeller = lab_short,
      scales = ifelse(use_free_y, "free_y", "fixed")
    ) +
    theme_facet +
    scale_color_brewer(palette = "Dark2") +
    labs(
      title = title,
      y = ylab,
      x = "Time series length (T)",
      linetype = "Input rho"
    )

  if (has_rho) {
    p <- p + scale_linetype_discrete(labels = function(x) paste0("rho=", x))
  }

  # Reference lines
  if (metric_col %in% c("mean_rel_bias", "sd_bias", "mean_bias")) {
    p <- p + geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")
  } else if (metric_col == "coverage_95") {
    p <- p + geom_hline(yintercept = 0.95, linetype = "dashed", color = "grey50")
  }

  if (!is.null(ylims)) {
    p <- p + coord_cartesian(ylim = ylims)
  }

  # Drop legends that would be redundant
  if (dplyr::n_distinct(df$Model) == 1) {
    p <- p + guides(color = "none")
  }
  if (!has_rho || dplyr::n_distinct(df$rho) == 1) {
    p <- p + guides(linetype = "none")
  }

  p
}

summarise_conditions <- function(df) {
  df |>
    group_by(Model, T, skew_level, direction, VARset, rho, param) |>
    summarise(
      mean_rel_bias = mean(rel_bias_eff, na.rm = TRUE),
      coverage_95 = mean(cover95_eff, na.rm = TRUE),
      mean_post_sd = mean(post_sd, na.rm = TRUE),
      emp_sd = sd(post_mean, na.rm = TRUE),
      mean_bias = mean(bias_eff, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      emp_sd = if_else(is.na(emp_sd), 0, emp_sd),
      sd_bias = mean_post_sd - emp_sd,
      RMSE = sqrt(mean_bias^2 + emp_sd^2)
    )
}
```

# 4. Exponential DGP: NG vs EG Performance

```{r condition_summaries}
#| label: condition_summaries
#| echo: false

core_params <- c("mu[1]", "mu[2]", "phi11", "phi12", "phi21", "phi22", "rho")

cond_core <- rep_df |>
  filter(param %in% core_params, mcmc_status != "Failed/Error") |>
  summarise_conditions()
```

## 4.1. Relative Bias

```{r exp_bias_rho, fig.height=4.5, fig.width=12}
#| label: exp_bias_rho
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "mean_rel_bias",
  ylab = "Mean relative bias",
  title = "Relative bias: dependence parameter rho",
  params = "rho",
  ylims = c(-0.3, 0.3)
)
```

```{r exp_bias_phi, fig.height=9.5, fig.width=12}
#| label: exp_bias_phi
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "mean_rel_bias",
  ylab = "Mean relative bias",
  title = "Relative bias: VAR coefficients (Phi elements)",
  params = c("phi11", "phi12", "phi21", "phi22"),
  use_free_y = TRUE
)
```

```{r exp_bias_mu, fig.height=6.0, fig.width=12}
#| label: exp_bias_mu
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "mean_bias",
  ylab = "Mean bias (truth = 0)",
  title = "Bias: intercepts (mu)",
  params = c("mu[1]", "mu[2]"),
  use_free_y = TRUE
)
```

**Interpretation.** Across $T$, EG is approximately unbiased for $\Phi$ and $\mu$. For $\rho$, the target in mixed-direction cells is $\rho_{\mathrm{eff}}$ (callout above): EG is close to unbiased, while NG exhibits attenuation in $|\rho|$, most pronounced at small $T$.

## 4.2. 95% Coverage

```{r exp_coverage_rho, fig.height=4.5, fig.width=12}
#| label: exp_coverage_rho
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "coverage_95",
  ylab = "Empirical 95% coverage",
  title = "95% coverage: dependence parameter rho",
  params = "rho",
  ylims = c(0.5, 1.0)
)
```

```{r exp_coverage_phi, fig.height=9.5, fig.width=12}
#| label: exp_coverage_phi
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "coverage_95",
  ylab = "Empirical 95% coverage",
  title = "95% coverage: VAR coefficients (Phi elements)",
  params = c("phi11", "phi12", "phi21", "phi22"),
  ylims = c(0.5, 1.0)
)
```

```{r exp_coverage_mu, fig.height=6.0, fig.width=12}
#| label: exp_coverage_mu
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "coverage_95",
  ylab = "Empirical 95% coverage",
  title = "95% coverage: intercepts (mu)",
  params = c("mu[1]", "mu[2]"),
  ylims = c(0.5, 1.0)
)
```

**Interpretation.** EG coverage is typically close to nominal for the core parameters. NG coverage shortfalls are concentrated in $\rho$, consistent with attenuation bias under marginal misspecification.

## 4.3. SD-Bias

```{r exp_sdbias_rho, fig.height=4.5, fig.width=12}
#| label: exp_sdbias_rho
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "sd_bias",
  ylab = "SD-bias (posterior SD − empirical SD)",
  title = "SD-bias: dependence parameter rho",
  params = "rho",
  use_free_y = FALSE
)
```

```{r exp_sdbias_phi, fig.height=9.5, fig.width=12}
#| label: exp_sdbias_phi
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "sd_bias",
  ylab = "SD-bias (posterior SD − empirical SD)",
  title = "SD-bias: VAR coefficients (Phi elements)",
  params = c("phi11", "phi12", "phi21", "phi22"),
  use_free_y = TRUE
)
```

```{r exp_sdbias_mu, fig.height=6.0, fig.width=12}
#| label: exp_sdbias_mu
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "sd_bias",
  ylab = "SD-bias (posterior SD − empirical SD)",
  title = "SD-bias: intercepts (mu)",
  params = c("mu[1]", "mu[2]"),
  use_free_y = TRUE
)
```

**Interpretation.** EG is generally well calibrated (SD-bias near 0). NG frequently shows negative SD-bias for $\rho$, indicating overconfident posterior uncertainty for dependence under misspecified margins.

# 5. Marginal Parameters

We report mean bias for the Exponential scale parameters in EG ($\sigma_{\mathrm{exp}}$) and the innovation standard deviations in NG ($\sigma$). Under the standardized DGP, the reference value is 1.

```{r marginal_params, fig.height=7.5, fig.width=12}
#| label: marginal_params
#| echo: false

cond_all <- rep_df |>
  filter(mcmc_status != "Failed/Error") |>
  summarise_conditions()

# EG marginal scales
sigma_exp_data <- cond_all |>
  filter(param %in% c("sigma_exp[1]", "sigma_exp[2]"), Model == "Exponential–Gaussian (EG)")

if (nrow(sigma_exp_data) > 0) {
  plot_metric_readable(
    sigma_exp_data,
    metric_col = "mean_bias",
    ylab = "Mean bias (estimate − 1)",
    title = "EG: bias for sigma_exp (truth = 1)",
    params = c("sigma_exp[1]", "sigma_exp[2]"),
    use_free_y = TRUE
  )
} else {
  message("No EG marginal scale parameters available.")
}
```

```{r marginal_params_ng, fig.height=7.5, fig.width=12}
#| label: marginal_params_ng
#| echo: false

# NG marginal SDs
sigma_ng_data <- cond_all |>
  filter(param %in% c("sigma[1]", "sigma[2]"), Model == "Normal–Gaussian (NG)")

if (nrow(sigma_ng_data) > 0) {
  plot_metric_readable(
    sigma_ng_data,
    metric_col = "mean_bias",
    ylab = "Mean bias (estimate − 1)",
    title = "NG: bias for sigma (truth = 1)",
    params = c("sigma[1]", "sigma[2]"),
    use_free_y = TRUE
  )
} else {
  message("No NG marginal SD parameters available.")
}
```

**Interpretation.** The $\sigma$ estimates under NG show small but systematic deviations from the true value of 1. As discussed in Study 1 (Section 7.1), these deviations arise from marginal misspecification but are not the mechanism driving $\rho$ attenuation—both phenomena stem from the same root cause (marginal misspecification) but through different pathways.
