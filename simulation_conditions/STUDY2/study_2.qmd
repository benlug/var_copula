---
title: "Study 2: Normal–Gaussian vs Exponential–Gaussian Copula VAR Under Exponential Innovations"
format:
  html:
    toc: true
    toc_depth: 3
    code-fold: true
    theme: lumen
    self-contained: true
  pdf:
    toc: true
    toc_depth: 3
execute:
  warning: false
  message: false
---

```{r setup}
#| label: setup
suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readr)
  library(ggplot2)
  library(stringr)
  library(knitr)
  library(RColorBrewer)

  # optional helpers used in some workstreams
  if (!requireNamespace("ggh4x", quietly = TRUE)) {
    message("Package 'ggh4x' not installed; proceeding without nested facets.")
  }
  if (!requireNamespace("patchwork", quietly = TRUE)) {
    message("Package 'patchwork' is recommended for arranging plots.")
  } else {
    library(patchwork)
  }
})

# ---- paths ----
DATA_DIR   <- file.path("data")
RES_DIR    <- file.path("results")
EXPORT_DIR <- file.path(RES_DIR, "exported_tables_s2")
dir.create(EXPORT_DIR, showWarnings = FALSE, recursive = TRUE)

# Study 2 pipelines sometimes write either sim_conditions.rds or sim_conditions_singlelevel.rds.
# We accept either to make the report portable across directory layouts.
.design_candidates <- c(
  file.path(DATA_DIR, "sim_conditions.rds"),
  file.path(DATA_DIR, "sim_conditions_singlelevel.rds")
)
.design_path <- .design_candidates[file.exists(.design_candidates)][1]

files <- list(
  cond   = file.path(RES_DIR, "summary_conditions.csv"),
  rep    = file.path(RES_DIR, "summary_replications.csv"),
  design = .design_path
)

if (is.na(files$design) || !all(file.exists(unlist(files)))) {
  stop(
    "Missing required input files. Expected:\n",
    " - ", files$rep, "\n",
    " - ", files$cond, "\n",
    " - ", paste(.design_candidates, collapse = " or "), "\n",
    "Run the Study 2 pipeline and the analysis script first."
  )
}
```

# 0. tl;dr

Across the design considered here (bivariate VAR(1), standardized Exponential margins, Gaussian copula dependence):

- **EG (Exponential–Gaussian)** is (i) approximately unbiased for the VAR dynamics $\Phi$ and intercepts $\mu$, and (ii) well calibrated for dependence when $\rho$ is interpreted on the correct scale in mixed-direction cells (see the callout below). Empirical coverage is close to 0.95 in most panels.
- **NG (Normal–Gaussian)** is computationally stable but exhibits **attenuation** in $|\rho|$ and corresponding under-coverage for $\rho$ under Exponential margins. Effects on $\Phi$ are materially smaller than for $\rho$.
- **Computation:** EG has more post-warmup divergences at small $T$, but (in this design) “Problematic” EG runs often have similar coverage to “Clean” EG runs.

::: {.callout-important}
## Copula sign under mirroring (critical for interpreting $\rho$ in mixed-direction cells)

Left-skew Exponential margins are produced by **mirroring** standardized Exponential innovations (multiplying by $-1$). For a Gaussian copula, mirroring exactly one margin corresponds to the transformation $u \mapsto 1-u$ on the PIT scale. Since $\Phi^{-1}(1-u) = -\Phi^{-1}(u)$, this flips the sign of the latent Gaussian score and therefore maps

$$
\rho \;\mapsto\; -\rho.
$$

Accordingly, in mixed-direction settings (e.g., $+-$), the **effective** copula correlation associated with the observed marginals is

$$
\rho_{\mathrm{eff}} \;=\; s_1 s_2\,\rho,\qquad s_j\in\{+1,-1\},
$$

where $s_j=-1$ indicates a mirrored (left-skew) margin.

**Implementation in this report.** All bias and coverage summaries for the copula parameter use $\rho_{\mathrm{eff}}$ as the target in mixed-direction cells. In the key simulation plots, the *input* $\rho\in\{0.30,0.50\}$ is encoded by **line type** (rather than an additional facet dimension) to keep panels readable.

**Nuance.** This is a parameterization issue, not a sampling pathology: if one compares estimates of $\rho$ to the unadjusted input value in mixed-direction cells, the plots will show an apparent “sign reversal” and near-zero coverage even when the model is correctly specified for the mirrored margins.
:::

::: {.callout-note}
## Relative bias for $\mu$

Because $\mu=0$ in the DGP, “relative bias” is reported as **absolute bias** for $\mu$ (i.e., $\widehat{\mu}-0$), using the convention $\text{rel\_bias}=\text{bias}$ when $|\text{truth}|$ is near 0.
:::

# 1. Introduction

## 1.1 Data generating process

We consider the bivariate VAR(1)

$$
Y_t = \mu + \Phi Y_{t-1} + \varepsilon_t,\qquad t=2,\ldots,T,
$$

with $\mu=\mathbf{0}$. Innovations $\varepsilon_t=(\varepsilon_{1t},\varepsilon_{2t})$ have **standardized Exponential** margins (mean 0, sd 1), with optional mirroring to induce left-skewness, and are coupled through a Gaussian copula with correlation parameter $\rho$.

## 1.2 Simulation design

A factorial design crosses $T\in\{50,100,200\}$, $\rho\in\{0.30,0.50\}$, directions $\{++, +-, --\}$, and two VAR matrices $\Phi\in\{A,B\}$.

```{r design_table}
#| label: design_table
#| echo: false

# NOTE: Double backslashes (\\) are required here because this is inside an R string
# that will be interpreted as LaTeX by kable(escape=FALSE).
design_summary <- tibble(
  Factor = c(
    "DGP Level",
    "Time Series Length (T)",
    "Copula Correlation ($\\rho$)",
    "VAR Parameters ($\\Phi$)",
    "",
    "Skewness Direction"
  ),
  Levels = c(
    "Standardized Exponential",
    "50, 100, 200",
    "0.30, 0.50 (reported as input; evaluation uses $\\rho_{\\mathrm{eff}}$ in mixed-direction cells)",
    "**Set A**: $\\begin{pmatrix} 0.40 & 0.10 \\\\ 0.10 & 0.40 \\end{pmatrix}$",
    "**Set B**: $\\begin{pmatrix} 0.55 & 0.10 \\\\ 0.10 & 0.25 \\end{pmatrix}$",
    "`++` (both right), `--` (both left), `+-` (mixed)"
  )
)

kable(design_summary, caption = "Simulation design factors (Study 2).", escape = FALSE)
```

::: {.callout-caution}
## Mixed-direction symmetry

Only one mixed-direction case ($+-$) is included. For the asymmetric VAR set $B$, $+-$ and $-+$ are not equivalent under variable relabeling. If mixed-direction symmetry is a design requirement, include both $+-$ and $-+$.
:::

## 1.3 Marginal shape illustration (standardized Exponential)

```{r dgp_marginal_distributions, fig.width=10, fig.height=6}
#| label: dgp_marginal_distributions
#| echo: false

set.seed(1)
N_draw <- 200000
u <- runif(N_draw)

# Exp(rate=1) has mean=1, sd=1; standardized draw is (x-1)
x_raw <- qexp(u, rate = 1)
x_std_right <- x_raw - 1
x_std_left  <- -(x_raw - 1)

plot_df <- tibble(
  value = c(x_std_right, x_std_left),
  dist  = rep(c("Exponential (std. right)", "Exponential (std. mirrored)"), each = N_draw)
)

ggplot(plot_df, aes(x = value, fill = dist)) +
  geom_histogram(aes(y = after_stat(density)), bins = 200, alpha = 0.35, position = "identity") +
  geom_density(linewidth = 0.9, alpha = 0.8) +
  stat_function(fun = dnorm, linewidth = 0.7, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  facet_wrap(~ dist, scales = "free", ncol = 2) +
  theme_bw(base_size = 12) +
  labs(
    title = "Standardized Exponential innovations used in Study 2",
    x = "value",
    y = "density"
  ) +
  guides(fill = "none")
```

# 2. Data loading & preparation

```{r}
#| label: data_prep

# ---- design grid ----
design_raw <- readRDS(files$design)

# harmonize DGP label column across pipelines
if (!"skew_level" %in% names(design_raw)) {
  if ("dgp_level" %in% names(design_raw)) {
    design_raw <- design_raw |> mutate(skew_level = as.character(dgp_level))
  } else {
    # if the design grid has no DGP label column, treat it as fixed Exponential
    design_raw <- design_raw |> mutate(skew_level = "Exponential")
  }
}

# harmonize rho name if needed
if (!"rho" %in% names(design_raw) && "copula_rho" %in% names(design_raw)) {
  design_raw <- design_raw |> mutate(rho = copula_rho)
}

required_cols <- c("condition_id", "skew_level", "direction", "T", "rho", "VARset")
missing_cols <- setdiff(required_cols, names(design_raw))
if (length(missing_cols) > 0) {
  stop(
    "Design grid is missing required columns: ", paste(missing_cols, collapse = ", "),
    "\nAvailable columns: ", paste(names(design_raw), collapse = ", ")
  )
}

design <- design_raw |>
  select(condition_id, skew_level, direction, T, rho, VARset)

# ---- summaries ----
cond_raw <- read_csv(files$cond, show_col_types = FALSE) |>
  left_join(design, by = "condition_id")

rep_raw <- read_csv(files$rep, show_col_types = FALSE) |>
  filter(!is.na(param)) |>
  left_join(design, by = "condition_id")

# keep only NG and EG
keep_models <- c("NG", "EG")
cond_raw <- cond_raw |> filter(model %in% keep_models)
rep_raw  <- rep_raw  |> filter(model %in% keep_models)

# parameter order for plotting
param_levels <- c(
  # EG marginal scales
  "sigma_exp[1]", "sigma_exp[2]",
  # NG marginal sds
  "sigma[1]", "sigma[2]",
  # core parameters
  "mu[1]", "mu[2]", "phi11", "phi12", "phi21", "phi22", "rho"
)

# apply factor levels and clear labels
prep_data <- function(df) {
  df |>
    mutate(
      param = factor(param, levels = param_levels),
      T = factor(T),
      skew_level = factor(skew_level, levels = sort(unique(skew_level))),
      direction = factor(direction, levels = c("++", "+-", "--")),
      rho_val = rho,
      VARset_val = VARset,
      rho = factor(rho, levels = sort(unique(rho))),
      VARset = factor(VARset, levels = sort(unique(VARset))),
      Model = factor(
        ifelse(model == "EG", "Exponential–Gaussian (EG)", "Normal–Gaussian (NG)"),
        levels = c("Normal–Gaussian (NG)", "Exponential–Gaussian (EG)")
      )
    )
}

rep_df <- prep_data(rep_raw)

# ---- rho_eff adjustment for mirrored margins (see callout) ----
# direction is a two-character string, with '-' indicating mirroring.
dir_chr <- as.character(rep_df$direction)
s1 <- ifelse(substr(dir_chr, 1, 1) %in% c("-", "−"), -1, 1)
s2 <- ifelse(substr(dir_chr, 2, 2) %in% c("-", "−"), -1, 1)
rep_df <- rep_df |>
  mutate(
    rho_truth = rho_val * (s1 * s2)
  )

# recompute truth/bias/coverage using rho_truth only for param=='rho'
eps <- 1e-8
rep_df <- rep_df |>
  mutate(
    truth_eff = if_else(param == "rho", rho_truth, truth),
    bias_eff = post_mean - truth_eff,
    rel_bias_eff = if_else(abs(truth_eff) < eps, bias_eff, bias_eff / abs(truth_eff)),
    cover95_eff = (l95 <= truth_eff) & (u95 >= truth_eff)
  )
```

## 2.1 MCMC classification and overview

We classify each fitted replication as:

- **Clean:** $\widehat{R}\le 1.01$ and no post-warmup divergences.
- **Problematic:** $\widehat{R}>1.01$ or at least one divergence.
- **Failed/Error:** non-OK status or missing diagnostics.

```{r}
#| label: mcmc_classification

RHAT_THRESHOLD <- 1.01

rep_df <- rep_df |>
  mutate(
    n_div_clean = if_else(is.na(n_div), 0L, as.integer(n_div)),
    mcmc_status = case_when(
      is.na(max_rhat) | status != "ok" ~ "Failed/Error",
      max_rhat > RHAT_THRESHOLD | n_div_clean > 0 ~ "Problematic",
      TRUE ~ "Clean"
    ),
    mcmc_status = factor(mcmc_status, levels = c("Clean", "Problematic", "Failed/Error"))
  )

mcmc_summary <- rep_df |>
  distinct(condition_id, rep_id, Model, mcmc_status, T, skew_level) |>
  group_by(Model, T, skew_level, mcmc_status) |>
  summarise(Count = n(), .groups = "drop")
```

```{r mcmc_status_plot, fig.height=12, fig.width=16}
#| label: mcmc_status_plot
#| echo: false

ggplot(mcmc_summary, aes(x = T, y = Count, fill = mcmc_status)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_grid(Model ~ skew_level) +
  labs(
    x = "Time series length (T)",
    y = "Number of replications",
    fill = "MCMC status",
    title = "MCMC convergence status by model (Study 2)"
  ) +
  theme_bw(base_size = 14) +
  scale_fill_manual(
    values = c("Clean" = "#4daf4a", "Problematic" = "#ff7f00", "Failed/Error" = "#e41a1c")
  )
```

```{r divergence_overview, fig.height=9, fig.width=16}
#| label: divergence_overview
#| echo: false

# Use one row per replication run (diagnostics are duplicated across params)
div_dist_data <- rep_df |>
  filter(param == "rho") |>
  distinct(condition_id, rep_id, Model, T, skew_level, n_div_clean, mcmc_status) |>
  filter(mcmc_status != "Failed/Error")

ggplot(div_dist_data, aes(x = T, y = n_div_clean, fill = Model)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6, position = position_dodge(width = 0.8)) +
  geom_point(
    size = 1.5, alpha = 0.4,
    position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8)
  ) +
  facet_grid(Model ~ skew_level) +
  theme_bw(base_size = 14) +
  labs(
    title = "Distribution of post-warmup divergent transitions",
    y = "Count of divergences (n_div)",
    x = "Time series length (T)"
  )
```

# 3. Helper plotting utilities

```{r analysis_helpers}
#| label: analysis_helpers

theme_standard <- theme_bw(base_size = 14) +
  theme(legend.position = "bottom")

# A more compact theme for many-facet simulation figures
theme_facet <- theme_bw(base_size = 11) +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal",
    legend.margin = margin(t = 2, r = 0, b = 0, l = 0, unit = "pt"),
    strip.text.x = element_text(size = 9),
    strip.text.y = element_text(size = 9),
    axis.text = element_text(size = 8),
    axis.title = element_text(size = 10),
    panel.spacing = grid::unit(0.7, "lines")
  )

# Compact labellers to avoid unreadable facet strips
lab_short <- labeller(
  direction = function(x) x,
  VARset    = function(x) paste0("VAR ", x),
  rho       = function(x) paste0("rho=", x),
  param     = function(x) x
)

# Readable metric plot: facet by (direction x VARset), encode input rho by linetype
plot_metric_readable <- function(data,
                                 metric_col,
                                 ylab,
                                 title,
                                 params = NULL,
                                 use_free_y = FALSE,
                                 ylims = NULL) {
  df <- data |>
    filter(!is.na(.data[[metric_col]]))

  if (!is.null(params)) {
    df <- df |> filter(param %in% params)
  }

  if (nrow(df) == 0) {
    message("Skipping plot '", title, "' due to missing data.")
    return(NULL)
  }

  # If rho is available, use linetype to avoid exploding the facet grid.
  has_rho <- "rho" %in% names(df)

  if (has_rho) {
    p <- ggplot(
      df,
      aes(
        x = T,
        y = .data[[metric_col]],
        color = Model,
        linetype = rho,
        group = interaction(Model, rho)
      )
    )
  } else {
    p <- ggplot(
      df,
      aes(
        x = T,
        y = .data[[metric_col]],
        color = Model,
        group = Model
      )
    )
  }

  p <- p +
    geom_line(linewidth = 0.9) +
    geom_point(size = 2.2) +
    facet_grid(
      param ~ direction + VARset,
      labeller = lab_short,
      scales = ifelse(use_free_y, "free_y", "fixed")
    ) +
    theme_facet +
    scale_color_brewer(palette = "Dark2") +
    labs(
      title = title,
      y = ylab,
      x = "Time series length (T)",
      linetype = "Input rho"
    )

  if (has_rho) {
    p <- p + scale_linetype_discrete(labels = function(x) paste0("rho=", x))
  }

  # Reference lines
  if (metric_col %in% c("mean_rel_bias", "sd_bias", "mean_bias")) {
    p <- p + geom_hline(yintercept = 0, linetype = "dashed", color = "grey50")
  } else if (metric_col == "coverage_95") {
    p <- p + geom_hline(yintercept = 0.95, linetype = "dashed", color = "grey50")
  }

  if (!is.null(ylims)) {
    p <- p + coord_cartesian(ylim = ylims)
  }

  # Drop legends that would be redundant
  if (dplyr::n_distinct(df$Model) == 1) {
    p <- p + guides(color = "none")
  }
  if (!has_rho || dplyr::n_distinct(df$rho) == 1) {
    p <- p + guides(linetype = "none")
  }

  p
}

summarise_conditions <- function(df) {
  df |>
    group_by(Model, T, skew_level, direction, VARset, rho, param) |>
    summarise(
      mean_rel_bias = mean(rel_bias_eff, na.rm = TRUE),
      coverage_95 = mean(cover95_eff, na.rm = TRUE),
      mean_post_sd = mean(post_sd, na.rm = TRUE),
      emp_sd = sd(post_mean, na.rm = TRUE),
      mean_bias = mean(bias_eff, na.rm = TRUE),
      .groups = "drop"
    ) |>
    mutate(
      emp_sd = if_else(is.na(emp_sd), 0, emp_sd),
      sd_bias = mean_post_sd - emp_sd,
      RMSE = sqrt(mean_bias^2 + emp_sd^2)
    )
}
```

# 4. Analysis: Exponential DGP (NG vs EG)

All summaries below are computed from replication-level results, excluding runs with `Failed/Error` status.

```{r}
#| label: condition_summaries

core_params <- c("mu[1]", "mu[2]", "phi11", "phi12", "phi21", "phi22", "rho")

cond_core <- rep_df |>
  filter(param %in% core_params, mcmc_status != "Failed/Error") |>
  summarise_conditions()
```

## 4.1 Relative bias

To improve readability, we (i) facet by **direction x VAR set** and (ii) encode the input copula parameter value ($\rho\in\{0.30,0.50\}$) using **line type** rather than adding another facet dimension.

```{r exp_bias_rho, fig.height=4.5, fig.width=12}
#| label: exp_bias_rho
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "mean_rel_bias",
  ylab = "Mean relative bias",
  title = "Relative bias: dependence parameter rho",
  params = "rho",
  use_free_y = FALSE
)
```

```{r exp_bias_phi, fig.height=9.5, fig.width=12}
#| label: exp_bias_phi
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "mean_rel_bias",
  ylab = "Mean relative bias",
  title = "Relative bias: VAR coefficients (Phi elements)",
  params = c("phi11", "phi12", "phi21", "phi22"),
  use_free_y = TRUE
)
```

```{r exp_bias_mu, fig.height=6.0, fig.width=12}
#| label: exp_bias_mu
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "mean_rel_bias",
  ylab = "Mean bias (truth = 0)",
  title = "Bias: intercepts (mu)",
  params = c("mu[1]", "mu[2]"),
  use_free_y = TRUE
)
```

**Interpretation.** Across $T$, EG is approximately unbiased for $\Phi$ and $\mu$. For $\rho$, the target in mixed-direction cells is $\rho_{\mathrm{eff}}$ (callout above): EG is close to unbiased, while NG exhibits attenuation in $|\rho|$, most pronounced at small $T$.

## 4.2 95% coverage

```{r exp_coverage_rho, fig.height=4.5, fig.width=12}
#| label: exp_coverage_rho
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "coverage_95",
  ylab = "Empirical 95% coverage",
  title = "95% coverage: dependence parameter rho",
  params = "rho",
  ylims = c(0.5, 1.0)
)
```

```{r exp_coverage_phi, fig.height=9.5, fig.width=12}
#| label: exp_coverage_phi
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "coverage_95",
  ylab = "Empirical 95% coverage",
  title = "95% coverage: VAR coefficients (Phi elements)",
  params = c("phi11", "phi12", "phi21", "phi22"),
  ylims = c(0.5, 1.0)
)
```

```{r exp_coverage_mu, fig.height=6.0, fig.width=12}
#| label: exp_coverage_mu
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "coverage_95",
  ylab = "Empirical 95% coverage",
  title = "95% coverage: intercepts (mu)",
  params = c("mu[1]", "mu[2]"),
  ylims = c(0.5, 1.0)
)
```

**Interpretation.** EG coverage is typically close to nominal for the core parameters. NG coverage shortfalls are concentrated in $\rho$, consistent with attenuation bias under marginal misspecification.

## 4.3 SD-bias

```{r exp_sdbias_rho, fig.height=4.5, fig.width=12}
#| label: exp_sdbias_rho
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "sd_bias",
  ylab = "SD-bias (posterior SD − empirical SD)",
  title = "SD-bias: dependence parameter rho",
  params = "rho",
  use_free_y = FALSE
)
```

```{r exp_sdbias_phi, fig.height=9.5, fig.width=12}
#| label: exp_sdbias_phi
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "sd_bias",
  ylab = "SD-bias (posterior SD − empirical SD)",
  title = "SD-bias: VAR coefficients (Phi elements)",
  params = c("phi11", "phi12", "phi21", "phi22"),
  use_free_y = TRUE
)
```

```{r exp_sdbias_mu, fig.height=6.0, fig.width=12}
#| label: exp_sdbias_mu
#| echo: false

plot_metric_readable(
  cond_core,
  metric_col = "sd_bias",
  ylab = "SD-bias (posterior SD − empirical SD)",
  title = "SD-bias: intercepts (mu)",
  params = c("mu[1]", "mu[2]"),
  use_free_y = TRUE
)
```

**Interpretation.** EG is generally well calibrated (SD-bias near 0). NG frequently shows negative SD-bias for $\rho$, indicating overconfident posterior uncertainty for dependence under misspecified margins.

# 5. Marginal scale parameters

We report mean bias for the Exponential scale parameters in EG ($\sigma_{\mathrm{exp}}$) and the innovation standard deviations in NG ($\sigma$). Under the standardized DGP, the reference value is 1.

```{r marginal_params, fig.height=7.5, fig.width=12}
#| label: marginal_params
#| echo: false

cond_all <- rep_df |>
  filter(mcmc_status != "Failed/Error") |>
  summarise_conditions()

# EG marginal scales
sigma_exp_data <- cond_all |>
  filter(param %in% c("sigma_exp[1]", "sigma_exp[2]"), Model == "Exponential–Gaussian (EG)")

if (nrow(sigma_exp_data) > 0) {
  plot_metric_readable(
    sigma_exp_data,
    metric_col = "mean_bias",
    ylab = "Mean bias (estimate − 1)",
    title = "EG: bias for sigma_exp (truth = 1)",
    params = c("sigma_exp[1]", "sigma_exp[2]"),
    use_free_y = TRUE
  )
} else {
  message("No EG marginal scale parameters available.")
}
```

```{r marginal_params_ng, fig.height=7.5, fig.width=12}
#| label: marginal_params_ng
#| echo: false

# NG marginal SDs
sigma_ng_data <- cond_all |>
  filter(param %in% c("sigma[1]", "sigma[2]"), Model == "Normal–Gaussian (NG)")

if (nrow(sigma_ng_data) > 0) {
  plot_metric_readable(
    sigma_ng_data,
    metric_col = "mean_bias",
    ylab = "Mean bias (estimate − 1)",
    title = "NG: bias for sigma (truth = 1)",
    params = c("sigma[1]", "sigma[2]"),
    use_free_y = TRUE
  )
} else {
  message("No NG marginal SD parameters available.")
}
```

# 6. EG-only diagnostics: role of MCMC pathologies

## 6.1 Coverage split: Clean vs Problematic

The full factorial design implies many small facets if we stratify coverage simultaneously by parameter, direction, VAR set, and the input copula correlation. For readability, the figure below *pools across direction and VAR set* and shows coverage trajectories by **MCMC status** (Clean vs Problematic), with the input $\\rho$ encoded by line type.

```{r coverage_status_split, fig.height=7.5, fig.width=12}
#| label: coverage_status_split
#| echo: false

cond_status <- rep_df |>
  filter(
    param %in% core_params,
    Model == "Exponential–Gaussian (EG)",
    mcmc_status %in% c("Clean", "Problematic")
  ) |>
  group_by(T, param, mcmc_status, rho) |>
  summarise(
    coverage_95 = mean(cover95_eff, na.rm = TRUE),
    N = n(),
    .groups = "drop"
  )

if (nrow(cond_status) > 0 && length(unique(cond_status$mcmc_status)) > 1) {
  ggplot(
    cond_status,
    aes(
      x = T,
      y = coverage_95,
      color = mcmc_status,
      linetype = rho,
      group = interaction(mcmc_status, rho)
    )
  ) +
    geom_line(linewidth = 1) +
    geom_point(size = 2.2) +
    geom_hline(yintercept = 0.95, linetype = "dashed", color = "grey50") +
    facet_wrap(~ param, ncol = 3, scales = "fixed") +
    theme_standard +
    labs(
      title = "EG 95% coverage by MCMC status (pooled over direction and VAR set)",
      y = "Empirical coverage",
      x = "Time series length (T)",
      color = "MCMC status",
      linetype = "Input rho"
    ) +
    coord_cartesian(ylim = c(0.5, 1.0))
} else {
  message("Insufficient EG status diversity for a split-by-status coverage plot.")
}
```

## 6.2 Absolute bias vs divergences

```{r bias_vs_divergences, fig.height=12, fig.width=16}
#| label: bias_vs_divergences
#| echo: false

div_bias_data <- rep_df |>
  filter(Model == "Exponential–Gaussian (EG)", param %in% core_params, mcmc_status != "Failed/Error") |>
  mutate(abs_bias = abs(bias_eff)) |>
  distinct(condition_id, rep_id, T, direction, VARset, rho, param, n_div_clean, abs_bias)

if (nrow(div_bias_data) > 0) {
  ggplot(div_bias_data, aes(x = n_div_clean, y = abs_bias)) +
    geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 1.7) +
    geom_smooth(method = "gam", linewidth = 1.0) +
    facet_grid(param ~ T, scales = "free_y") +
    theme_standard +
    labs(
      title = "EG: absolute bias vs divergence count",
      x = "Number of divergences (post-warmup)",
      y = "Absolute bias |estimate − truth|"
    )
}
```

# 7. Export tables

```{r export_tables}
#| label: export_tables
#| echo: false

write_csv(cond_core, file.path(EXPORT_DIR, "study2_core_condition_summary.csv"))
write_csv(cond_all,  file.path(EXPORT_DIR, "study2_all_condition_summary.csv"))
```

# 8. One-paragraph abstract

Under a bivariate VAR(1) with standardized Exponential innovations and Gaussian-copula dependence, we compare a Normal–Gaussian copula VAR (NG) with an Exponential–Gaussian copula VAR (EG). EG is well calibrated for $\mu$ and $\Phi$ and, when evaluated against the effective copula correlation $\rho_{\mathrm{eff}}$ implied by marginal mirroring in mixed-direction designs, also recovers dependence with near-nominal interval coverage. NG is computationally stable but exhibits attenuation and under-coverage for $\rho$, consistent with misspecified probability integral transforms. EG displays more divergent transitions at small sample sizes; nevertheless, within this design and tuning, coverage is typically similar across “Clean” and “Problematic” EG fits and absolute bias is only weakly related to divergence counts.
