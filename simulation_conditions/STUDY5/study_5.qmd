---
title: "Study 5: Layer Sensitivity in Exponential–Gaussian Copula VAR — Indicator vs. Latent Skewness"
format:
  pdf:
    toc: true
    toc_depth: 3
execute:
  warning: false
  message: false
---

```{r setup}
#| label: setup
#| echo: false
suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(readr)
  library(ggplot2)
  library(stringr)
  library(knitr)
  library(RColorBrewer)

  if (!requireNamespace("patchwork", quietly = TRUE)) {
    message("Package 'patchwork' is recommended for arranging plots.")
  } else {
    library(patchwork)
  }
})

# ---- paths ----
DATA_DIR   <- file.path("data")
RES_DIR    <- file.path("results_sem")
EXPORT_DIR <- file.path(RES_DIR, "exported_tables_s5")
dir.create(EXPORT_DIR, showWarnings = FALSE, recursive = TRUE)

files <- list(
  rep    = file.path(RES_DIR, "summary_replications_sem.csv"),
  cond   = file.path(RES_DIR, "summary_conditions_sem.csv"),
  design = file.path(DATA_DIR, "sim_conditions_sem.rds")
)

if (!all(file.exists(unlist(files)))) {
  stop(
    "Missing required input files. Expected:\n",
    " - ", files$rep, "\n",
    " - ", files$cond, "\n",
    " - ", files$design, "\n",
    "Run the Study 5 pipeline (run_pipeline_SEM.R) and analysis_sem.R first."
  )
}

# ---- plotting defaults (match Studies 1–3) ----
theme_set(
  theme_bw(base_size = 13) +
    theme(
      panel.grid.minor = element_blank(),
      strip.background = element_rect(fill = "grey95", colour = NA),
      strip.text = element_text(face = "bold"),
      legend.position = "bottom"
    )
)

pal_status <- c(
  "Clean" = "#4daf4a",
  "Problematic" = "#ff7f00",
  "Failed/Error" = "#e41a1c"
)

pal_model <- c(
  "EI" = "#1b9e77",
  "EL" = "#d95f02"
)

RHAT_THRESHOLD <- 1.01
```

# 0. Summary

This study evaluates whether (and how strongly) **dynamic parameter inference** for a bivariate VAR(1) depends on *where* non-Gaussianity is placed in the hierarchy when fitting an **Exponential–Gaussian (EG) copula** model.

Two alternative model structures are compared:

- **EI (Indicator‑Exponential):** signed/shifted Exponential margins on **measurement errors** with a Gaussian copula at the measurement layer.
- **EL (Latent‑Exponential):** signed/shifted Exponential margins on **VAR innovations** with a Gaussian copula at the innovation layer.

We generate data under two corresponding DGPs (Study A and Study B) and fit both EI and EL in every condition. The central question is:

> When the Exponential‑copula layer is *misplaced* (indicator vs latent), does inference for $(\mu, \Phi, \rho)$ degrade meaningfully, and if so, in what way (bias, calibration, or sampling pathologies)?

# 1. Introduction

The Exponential–Gaussian copula construction separates:

1. **marginals** (signed/shifted Exponential) and
2. **dependence** (Gaussian copula with parameter $\rho$).

This study specifically probes *layer sensitivity*: whether placing that copula‑marginal construction on **measurement residuals** vs **state/innovation residuals** yields meaningfully different posterior behaviour for the VAR dynamics.

## 1.1 Data generating processes

All conditions use a fixed bivariate VAR(1) coefficient matrix $\Phi$ and $\mu = 0$.

### Study A: indicator‑skew DGP

Latent state evolves with Gaussian innovations:

$$
x_t = \mu + \Phi x_{t-1} + u_t, \qquad u_t \sim \mathcal{N}(0, I_2)
$$

Observed indicators equal state plus **signed/shifted Exponential** measurement residuals:

$$
y_t = x_t + \varepsilon_t,
$$

where each component of $\varepsilon_t$ is standardized to mean 0 and variance 1 using the transforms:

- Right‑skew: $\varepsilon = X - 1$, $X \sim \text{Exp}(1)$, support $\varepsilon \ge -1$.
- Left‑skew:  $\varepsilon = 1 - X$, $X \sim \text{Exp}(1)$, support $\varepsilon \le 1$.

Dependence between $(\varepsilon_{t1},\varepsilon_{t2})$ is imposed by a **Gaussian copula** with correlation parameter $\rho$.

### Study B: latent‑skew DGP

Observed series follow a VAR(1) recursion where innovations are signed/shifted Exponential with Gaussian‑copula dependence:

$$
y_t = \mu + \Phi y_{t-1} + \zeta_t,
$$

with $(\zeta_{t1},\zeta_{t2})$ generated from signed/shifted Exponential margins and Gaussian copula correlation $\rho$.

## 1.2 Experimental factors

Conditions vary:

- **DGP type:** Study A vs Study B
- **Direction pattern:** `++` (both right‑skew) vs `+-` (mixed skew)
- **Length:** $T \in \{100, 200\}$
- **Dependence:** $\rho = 0.30$

Both models (EI and EL) are fit for each replication in each condition.

```{r design_grid}
#| label: design_grid
#| echo: false

design <- readRDS(files$design) |>
  select(condition_id, sem_study, direction, T, rho, n_reps)

design |>
  group_by(sem_study, direction, T, rho) |>
  summarise(N_conditions = n(), n_reps = first(n_reps), .groups = "drop") |>
  arrange(sem_study, direction, T) |>
  knitr::kable(caption = "Design grid overview")
```

# 2. Data loading and preparation

```{r data_prep}
#| label: data_prep
#| echo: false

design <- readRDS(files$design)

cond_raw <- read_csv(files$cond, show_col_types = FALSE) |>
  left_join(design, by = "condition_id")

# NOTE: DO NOT drop param==NA rows.
# Those rows carry failed/missing fit statuses which are needed for
# the MCMC-status summaries (consistent with Studies 1–3).
rep_raw <- read_csv(files$rep, show_col_types = FALSE) |>
  left_join(design, by = "condition_id")

param_levels <- c(
  "sigma_exp[1]", "sigma_exp[2]",
  "mu[1]", "mu[2]",
  "phi11", "phi12", "phi21", "phi22",
  "rho"
)

label_sem <- c(
  A_indicator = "Study A (indicator-skew DGP)",
  B_latent    = "Study B (latent-skew DGP)"
)

prep <- function(df) {
  df |>
    mutate(
      param = factor(param, levels = param_levels),
      T = factor(T),
      sem_study = factor(sem_study, levels = names(label_sem), labels = unname(label_sem)),
      direction = factor(direction, levels = c("++", "+-")),
      Model = factor(model, levels = c("EI", "EL"),
                     labels = c("EI (Indicator-Exponential)", "EL (Latent-Exponential)"))
    )
}

cond <- prep(cond_raw) |>
  mutate(RMSE = sqrt(mean_bias^2 + coalesce(emp_sd^2, 0)))

rep_df <- prep(rep_raw)

core_params <- c("mu[1]", "mu[2]", "phi11", "phi12", "phi21", "phi22", "rho")
sigma_params <- c("sigma_exp[1]", "sigma_exp[2]")
```

## 2.1 MCMC classification and overview

Replication runs are classified using the same conventions as Studies 1–3:

- **Failed/Error:** the fit did not complete successfully (`status != "ok"`) or diagnostics are missing.
- **Problematic:** sampling completed but either (i) `max_rhat > 1.01` or (ii) `n_div > 0` (if recorded).
- **Clean:** sampling completed and diagnostics are within thresholds.

```{r mcmc_classification}
#| label: mcmc_classification
#| echo: false

has_divs <- any(!is.na(rep_df$n_div))

rep_level <- rep_df |>
  distinct(condition_id, rep_id, Model, status, n_div, max_rhat, sem_study, direction, T) |>
  mutate(
    mcmc_status = case_when(
      is.na(max_rhat) | status != "ok" ~ "Failed/Error",
      max_rhat > RHAT_THRESHOLD | (has_divs & n_div > 0) ~ "Problematic",
      TRUE ~ "Clean"
    ),
    mcmc_status = factor(mcmc_status, levels = c("Clean", "Problematic", "Failed/Error"))
  )

mcmc_summary <- rep_level |>
  group_by(Model, sem_study, direction, T, mcmc_status) |>
  summarise(Count = n(), .groups = "drop")
```

```{r mcmc_status_plot, fig.height=6, fig.width=11}
#| label: mcmc_status_plot
#| echo: false

ggplot(mcmc_summary, aes(x = T, y = Count, fill = mcmc_status)) +
  geom_bar(stat = "identity") +
  facet_grid(Model ~ sem_study + direction) +
  scale_fill_manual(values = pal_status) +
  labs(
    x = "T",
    y = "Number of replications",
    fill = "MCMC status",
    title = "MCMC convergence status by condition"
  )
```

```{r mcmc_div_plot, fig.height=6, fig.width=11}
#| label: mcmc_div_plot
#| echo: false

if (has_divs) {
  div_df <- rep_level |>
    filter(mcmc_status != "Failed/Error")

  ggplot(div_df, aes(x = T, y = n_div)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(alpha = 0.35, position = position_jitter(width = 0.15, height = 0)) +
    facet_grid(Model ~ sem_study + direction) +
    labs(
      title = "Divergent transitions per replication (post-warmup)",
      x = "T",
      y = "n_div"
    )
} else {
  plot.new(); title("No divergence counts were recorded in the fit outputs.")
}
```

# 3. Results: recovery of core dynamic parameters

Condition‑level metrics are computed over replications with `status == "ok"` (completed sampling). This matches Studies 1–3 and avoids silently dropping non‑converged runs.

```{r bias_core, fig.height=8, fig.width=11}
#| label: bias_core
#| echo: false

cond_core <- cond |>
  filter(param %in% core_params)

ggplot(cond_core, aes(x = T, y = mean_bias, colour = Model, group = Model)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.6) +
  facet_grid(param ~ sem_study + direction, scales = "free_y") +
  scale_colour_manual(values = pal_model) +
  labs(
    title = "Bias of core parameters (condition means)",
    x = "T",
    y = "Mean bias",
    colour = "Model"
  )
```

```{r coverage_core, fig.height=8, fig.width=11}
#| label: coverage_core
#| echo: false

ggplot(cond_core, aes(x = T, y = coverage_95, colour = Model, group = Model)) +
  geom_hline(yintercept = 0.95, linetype = 2) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.6) +
  facet_grid(param ~ sem_study + direction) +
  scale_colour_manual(values = pal_model) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(
    title = "95% interval coverage of core parameters",
    x = "T",
    y = "Empirical coverage",
    colour = "Model"
  )
```

```{r sd_bias_core, fig.height=8, fig.width=11}
#| label: sd_bias_core
#| echo: false

ggplot(cond_core, aes(x = T, y = sd_bias, colour = Model, group = Model)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.6) +
  facet_grid(param ~ sem_study + direction, scales = "free_y") +
  scale_colour_manual(values = pal_model) +
  labs(
    title = "SD bias (mean posterior SD − empirical SD of posterior means)",
    x = "T",
    y = "SD bias",
    colour = "Model"
  )
```

# 4. Secondary parameters: shift terms $\sigma_{\text{exp}}$

The Exponential likelihood is implemented via a shift so that the transformed variable remains positive.
As a result, $\sigma_{\text{exp}}$ is best viewed as a *nuisance/feasibility* term (and may be sample‑dependent under the soft‑max construction in the Stan code).

```{r sigma_bias, fig.height=5, fig.width=11}
#| label: sigma_bias
#| echo: false

cond_sigma <- cond |>
  filter(param %in% sigma_params)

ggplot(cond_sigma, aes(x = T, y = mean_bias, colour = Model, group = Model)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_line(linewidth = 0.6) +
  geom_point(size = 1.6) +
  facet_grid(param ~ sem_study + direction, scales = "free_y") +
  scale_colour_manual(values = pal_model) +
  labs(
    title = "Bias of sigma_exp (reference truth set to 1)",
    x = "T",
    y = "Mean bias",
    colour = "Model"
  )
```

# 5. Exportable summary tables

```{r exports}
#| label: exports
#| echo: false

# A compact table focused on the VAR dynamics and copula parameter.
export_tbl <- cond |>
  filter(param %in% core_params) |>
  select(sem_study, direction, T, rho, Model, param,
         N_expected, N_ok, prop_ok,
         mean_bias, coverage_95, mean_post_sd, emp_sd, sd_bias, RMSE,
         mean_n_div, mean_rhat)

write_csv(export_tbl, file.path(EXPORT_DIR, "study5_core_parameter_summary.csv"))

export_tbl |>
  mutate(across(where(is.numeric), ~ round(.x, 3))) |>
  knitr::kable(caption = "Exportable core-parameter summary (rounded)")
```

```{r export_path_note}
#| label: export_path_note
#| echo: false

cat("Tables written to:", EXPORT_DIR)
```
