{
  "hash": "fd872f4574c332c35fa59bfd7b8e5b73",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"SEM Skewness Study: Indicator vs. Latent (Exponential Margins, Gaussian Copula)\"\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: true\n    theme: lumen\n    self-contained: true\n  pdf:\n    toc: true\n    toc-depth: 3\nexecute:\n  warning: false\n  message: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages({\n  library(dplyr)\n  library(tidyr)\n  library(readr)\n  library(ggplot2)\n  library(stringr)\n  library(knitr)\n})\n\n# Paths for the SEM study\nDATA_DIR   <- \"data\"\nRES_DIR    <- \"results_sem\"\nEXPORT_DIR <- file.path(RES_DIR, \"exported_tables\")\ndir.create(EXPORT_DIR, showWarnings = FALSE, recursive = TRUE)\n\nfiles <- list(\n  cond   = file.path(RES_DIR,  \"summary_conditions_sem.csv\"),\n  rep    = file.path(RES_DIR,  \"summary_replications_sem.csv\"),\n  design = file.path(DATA_DIR, \"sim_conditions_sem.rds\")\n)\n\nif (!all(file.exists(unlist(files)))) {\n  stop(\"Missing input(s): expecting results_sem/summary_*.csv and data/sim_conditions_sem.rds. \",\n       \"Please run analysis_sem.R first.\")\n}\n\n# Load design and summaries\ndesign <- readRDS(files$design) |>\n  dplyr::select(condition_id, sem_study, direction, `T`, rho)\n\n\ncond_raw <- read_csv(files$cond, show_col_types = FALSE)\nrep_raw  <- read_csv(files$rep,  show_col_types = FALSE)\n\n# Join design fields onto the summaries\ncond   <- cond_raw |> left_join(design, by = \"condition_id\")\nrep_df <- rep_raw  |> filter(!is.na(param)) |> left_join(design, by = \"condition_id\")\n\n# Make \"n\" (= T) numeric for plotting on the x-axis\nrep_df <- rep_df |> mutate(n = as.numeric(T))\ncond   <- cond   |> mutate(n = as.numeric(T))\n\n# Factor labels from the actual design (no hard-coding)\ndir_levels <- unique(design$direction) |> as.character() |> sort()\nrho_levels <- unique(design$rho)       |> as.character() |> sort()\nT_levels   <- unique(design$T)         |> as.character() |> sort()\n\nmodel_labs <- c(EI = \"Indicator-skew (EI)\", EL = \"Latent-skew (EL)\")\n\nrep_df <- rep_df |>\n  mutate(\n    Model = factor(model, levels = c(\"EI\",\"EL\"), labels = model_labs),\n    sem_study = factor(sem_study, levels = c(\"A_indicator\",\"B_latent\"),\n                       labels = c(\"A: indicator-skew\",\"B: latent-skew\")),\n    T  = factor(T,  levels = T_levels),\n    rho = factor(rho, levels = rho_levels),\n    direction = factor(direction, levels = dir_levels)\n  )\n\ncond <- cond |>\n  mutate(\n    Model = factor(model, levels = c(\"EI\",\"EL\"), labels = model_labs),\n    sem_study = factor(sem_study, levels = c(\"A_indicator\",\"B_latent\"),\n                       labels = c(\"A: indicator-skew\",\"B: latent-skew\")),\n    T  = factor(T,  levels = T_levels),\n    rho = factor(rho, levels = rho_levels),\n    direction = factor(direction, levels = dir_levels)\n  )\n\n# Parameter groups\ncore_params  <- c(\"mu[1]\",\"mu[2]\",\"phi11\",\"phi12\",\"phi21\",\"phi22\",\"rho\")\nextra_params <- c(\"sigma_exp[1]\",\"sigma_exp[2]\")\n\n# Simple ggplot theme\ntheme_standard <- theme_bw(base_size = 13)\n\n`%||%` <- function(a,b) if (!is.null(a)) a else b\n```\n:::\n\n\n\n\n# 0. tl;dr\n\n**Question.** How do estimates and uncertainty behave when **skewness lives at different layers** of a SEM/VAR(1)?\n\n* **Study A (EI):** skewed **measurement errors** (exponential margins), Gaussian state\n* **Study B (EL):** skewed **state innovations** (exponential margins), no measurement error\n\n**Key expectations (to confirm with the figures below):**\n\n* **Layer matters.** When fitted at the correct layer, both EI and EL should recover the VAR dynamics ($\\Phi$) and intercepts ($\\mu$) well at typical lengths such as $T=100$.\n* **($\\rho$) sensitivity.** The Gaussian copula correlation ($\\rho$) is estimated on the **active layer**; misspecifying the layer (fitting EI to EL data or vice versa) tends to attenuate ($\\hat{\\rho}$).\n* **Diagnostics vs. inference.** Occasional divergences (near one-sided bounds) need not imply poor inference for ($\\Phi$) or ($\\mu$); still examine coverage by parameter.\n\n# 1. Introduction\n\nWe compare two bivariate SEM/VAR(1) formulations with **exponential one-sided margins** and a **Gaussian copula**:\n\n* **EI (indicator-skew):**\n  $$\n  \\mathbf s_t=\\boldsymbol\\mu+\\mathbf B,\\mathbf s_{t-1}+\\boldsymbol\\eta_t,\\quad\n  \\boldsymbol\\eta_t\\sim\\mathcal N(\\mathbf 0,\\mathbf I),\\qquad\n  \\mathbf y_t=\\mathbf s_t+\\boldsymbol\\varepsilon_t.\n  $$\n  Skewness and ($\\rho$) live in ($\\boldsymbol\\varepsilon_t$).\n\n* **EL (latent-skew):**\n  $$\n  \\mathbf y_t=\\boldsymbol\\mu+\\mathbf B,\\mathbf y_{t-1}+\\boldsymbol\\zeta_t.\n  $$\n  Skewness and ($\\rho$) live in ($\\boldsymbol\\zeta_t$).\n\nEach margin uses an **exponential** law with **sign** (`direction`):\nright-skew ((+)): ($e \\ge -s$), left-skew ((-)): ($e \\le s$); true **scale** ($s=1$).\nA **Gaussian copula** with correlation ($\\rho$) couples the two margins at each ($t$) on the **active layer**.\n\n## 1.1 Simulation Design\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: SEM study design (current grid).\n\n|Factor                                      |Levels                                                              |\n|:-------------------------------------------|:-------------------------------------------------------------------|\n|SEM Study (active layer)                    |A: indicator-skew (measurement), B: latent-skew (innovations)       |\n|Skew Direction (per margin)                 |+-, ++                                                              |\n|Copula Correlation ($\\rho$) at active layer |0.3                                                                 |\n|Time Series Length ($T$) ≡ sample size $n$  |100, 200                                                            |\n|VAR(1) Coefficients ($\\mathbf{B}$)          |Fixed as $\\begin{pmatrix} 0.55 & 0.10 \\\\ 0.10 & 0.25 \\end{pmatrix}$ |\n|Replications / cell                         |varies                                                              |\n|Total Conditions                            |8                                                                   |\n\n\n:::\n:::\n\n\n\n\n# 2. Data loading and preparation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Condition-level helper\ncond <- cond |>\n  mutate(RMSE = sqrt((mean_bias %||% 0)^2 + (emp_sd %||% 0)^2))\n\n# Replication-level MCMC classification\nRHAT_THRESHOLD <- 1.01\nrep_df <- rep_df |>\n  mutate(\n    mcmc_status = dplyr::case_when(\n      is.na(max_rhat) | status != \"ok\" ~ \"Failed/Error\",\n      max_rhat > RHAT_THRESHOLD | (n_div %||% 0) > 0 ~ \"Problematic\",\n      TRUE ~ \"Clean\"\n    ),\n    mcmc_status = factor(mcmc_status, levels = c(\"Clean\",\"Problematic\",\"Failed/Error\"))\n  )\n```\n:::\n\n\n\n\n## 2.1 MCMC overview (x-axis: $n$)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_counts <- rep_df |>\n  distinct(condition_id, rep_id, Model, sem_study, direction, rho, n, mcmc_status) |>\n  count(Model, sem_study, direction, rho, n, mcmc_status, name = \"N\")\n\nggplot(mcmc_counts, aes(x = n, y = N, fill = mcmc_status, group = mcmc_status)) +\n  geom_col(position = \"stack\") +\n  facet_grid(Model + sem_study ~ direction + rho, labeller = label_both) +\n  scale_fill_manual(values = c(\"Clean\"=\"#4daf4a\",\"Problematic\"=\"#ff7f00\",\"Failed/Error\"=\"#e41a1c\")) +\n  labs(title = \"MCMC status counts by model / study / direction / ρ (x-axis = n)\",\n       x = \"n (time points T)\", y = \"Number of replications\", fill = \"Status\") +\n  theme_standard\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/mcmc_overview_counts-1.png){width=1152}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndiv_data <- rep_df |>\n  filter(param == \"rho\") |>\n  distinct(condition_id, rep_id, Model, sem_study, direction, rho, n, n_div, mcmc_status) |>\n  filter(mcmc_status != \"Failed/Error\")\n\nggplot(div_data, aes(x = n, y = n_div, color = Model)) +\n  geom_boxplot(outlier.shape = NA, alpha = 0.6) +\n  geom_jitter(width = 2, alpha = 0.4, size = 1.5) +\n  facet_grid(sem_study ~ direction + rho, labeller = label_both) +\n  labs(title = \"Divergent transitions per run (post-warmup; x-axis = n)\",\n       x = \"n (time points T)\", y = \"n_div\") +\n  theme_standard\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/mcmc_divergence_distribution-1.png){width=1152}\n:::\n:::\n\n\n\n\n# 3. Core parameter accuracy ($\\Phi$, $\\mu$, $\\rho$; x-axis = $n$)\n\nWe summarize **bias**, **coverage**, and **uncertainty calibration** for\n${\\mu_1,\\mu_2,\\phi_{11},\\phi_{12},\\phi_{21},\\phi_{22},\\rho}$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_metric_n <- function(df, metric_col, title, ylab,\n                          use_free_y = FALSE, ylims = NULL) {\n  d <- df |> filter(param %in% core_params, !is.na(.data[[metric_col]]))\n  if (nrow(d) == 0) return(NULL)\n  p <- ggplot(d, aes(x = as.numeric(as.character(n)), y = .data[[metric_col]],\n                     color = Model, group = Model)) +\n    geom_line(position = position_dodge(2), linewidth = 0.8) +\n    geom_point(position = position_dodge(2), size = 2.2) +\n    facet_grid(param ~ sem_study + direction + rho, labeller = label_both,\n               scales = ifelse(use_free_y,\"free_y\",\"fixed\")) +\n    labs(title = title, x = \"n (time points T)\", y = ylab, color = \"Model\") +\n    theme_standard\n  if (metric_col %in% c(\"mean_rel_bias\",\"sd_bias\")) {\n    p <- p + geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey40\")\n  } else if (metric_col == \"coverage_95\") {\n    p <- p + geom_hline(yintercept = 0.95, linetype = \"dashed\", color = \"grey40\")\n  }\n  if (!is.null(ylims)) p <- p + coord_cartesian(ylim = ylims)\n  p\n}\n\ncond_core <- cond |> filter(param %in% core_params)\n```\n:::\n\n\n\n\n### 3.1 Relative bias\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_metric_n(cond_core, \"mean_rel_bias\",\n              \"Relative bias (core parameters; x-axis = n)\",\n              \"Mean relative bias\", use_free_y = TRUE)\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/core_relbias-1.png){width=1344}\n:::\n:::\n\n\n\n\n### 3.2 95% coverage\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_metric_n(cond_core, \"coverage_95\",\n              \"Empirical 95% coverage (core parameters; x-axis = n)\",\n              \"Coverage\", ylims = c(0.8, 1.0))\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/core_coverage-1.png){width=1344}\n:::\n:::\n\n\n\n\n### 3.3 SD-bias (posterior SD – empirical SD)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_metric_n(cond_core, \"sd_bias\",\n              \"SD-bias (posterior SD − empirical SD; x-axis = n)\",\n              \"SD-bias\", use_free_y = TRUE)\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/core_sdbias-1.png){width=1344}\n:::\n:::\n\n\n\n\n# 4. Marginal scale parameters ($\\sigma_{\\exp}$; x-axis = $n$)\n\nBoth EI and EL estimate $\\sigma_{\\exp}$ but on different layers:\nEI: **measurement error**; EL: **innovations**. Truth: $\\sigma_{\\exp}=1$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_metric_any_n <- function(df, metric_col, title, ylab,\n                              use_free_y = FALSE, ylims = NULL) {\n  d <- df |> filter(!is.na(.data[[metric_col]]))\n  if (nrow(d) == 0) return(NULL)\n  p <- ggplot(d, aes(x = as.numeric(as.character(n)), y = .data[[metric_col]],\n                     color = Model, group = Model)) +\n    geom_line(position = position_dodge(2), linewidth = 0.8) +\n    geom_point(position = position_dodge(2), size = 2.2) +\n    facet_grid(param ~ sem_study + direction + rho, labeller = label_both,\n               scales = ifelse(use_free_y,\"free_y\",\"fixed\")) +\n    labs(title = title, x = \"n (time points T)\", y = ylab, color = \"Model\") +\n    theme_standard\n  if (metric_col %in% c(\"mean_rel_bias\",\"sd_bias\")) {\n    p <- p + geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey40\")\n  } else if (metric_col == \"coverage_95\") {\n    p <- p + geom_hline(yintercept = 0.95, linetype = \"dashed\", color = \"grey40\")\n  }\n  if (!is.null(ylims)) p <- p + coord_cartesian(ylim = ylims)\n  p\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncond_sigma <- cond |> filter(param %in% c(\"sigma_exp[1]\",\"sigma_exp[2]\"))\n\np1 <- plot_metric_any_n(cond_sigma, \"mean_rel_bias\",\n                        \"Relative bias (sigma_exp; x-axis = n)\", \"Mean relative bias\", use_free_y = TRUE)\n\np2 <- plot_metric_any_n(cond_sigma, \"coverage_95\",\n                        \"Empirical 95% coverage (sigma_exp; x-axis = n)\", \"Coverage\", ylims = c(0.8, 1.0))\n\nprint(p1); print(p2)\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/sigma_exp_section-1.png){width=1344}\n:::\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/sigma_exp_section-2.png){width=1344}\n:::\n:::\n\n\n\n\n# 5. Clean vs. Problematic (split by MCMC status; x-axis = $n$)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate_by_status <- function(df) {\n  df |>\n    filter(mcmc_status != \"Failed/Error\", param %in% core_params) |>\n    group_by(condition_id, Model, param, mcmc_status, sem_study, direction, rho, n) |>\n    summarise(\n      N_valid      = n(),\n      mean_rel_bias= mean(rel_bias, na.rm = TRUE),\n      coverage_95  = mean(cover95, na.rm = TRUE),\n      mean_post_sd = mean(post_sd, na.rm = TRUE),\n      emp_sd       = sd(post_mean, na.rm = TRUE),\n      mean_bias    = mean(bias, na.rm = TRUE),\n      .groups      = \"drop\"\n    ) |>\n    mutate(\n      emp_sd = ifelse(is.na(emp_sd), 0, emp_sd),\n      sd_bias = mean_post_sd - emp_sd,\n      RMSE = sqrt((mean_bias %||% 0)^2 + (emp_sd %||% 0)^2)\n    )\n}\n\ncond_status <- aggregate_by_status(rep_df)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstatus_overview <- cond_status |>\n  group_by(Model, param, sem_study, direction, rho, n, mcmc_status) |>\n  summarise(mean_coverage = mean(coverage_95, na.rm = TRUE), .groups = \"drop\")\n\nggplot(status_overview,\n       aes(x = as.numeric(as.character(n)), y = mean_coverage, color = mcmc_status, group = mcmc_status)) +\n  geom_line(linewidth = 0.8) +\n  geom_point(size = 2.2) +\n  facet_grid(Model + sem_study ~ param + direction + rho, labeller = label_both) +\n  geom_hline(yintercept = 0.95, linetype = \"dashed\", color = \"grey40\") +\n  scale_color_manual(values = c(\"Clean\"=\"#4daf4a\",\"Problematic\"=\"#ff7f00\")) +\n  labs(title = \"Coverage by MCMC status (core parameters; x-axis = n)\",\n       x = \"n (time points T)\", y = \"Mean coverage\", color = \"Status\") +\n  theme_standard\n```\n\n::: {.cell-output-display}\n![](study_5_files/figure-html/coverage_status_split-1.png){width=1152}\n:::\n:::\n\n\n\n\n# 6. Export tidy tables\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1) Main condition-level summary (with design joined)\nexport_cond <- cond |>\n  dplyr::select(\n    condition_id, Model, sem_study, direction, rho,\n    n, T = any_of(\"T\"),   # <-- quote 'T' so select() doesn't see TRUE\n    param,\n    N_valid, N_truth_avail,\n    mean_rel_bias, coverage_95, RMSE,\n    mean_post_sd, emp_sd, sd_bias,\n    mean_n_div, prop_div, mean_rhat\n  )\n\nreadr::write_csv(export_cond, file.path(EXPORT_DIR, \"sem_analysis_conditions.csv\"))\n\n# 2) Coverage by MCMC status (core only)\nexport_status <- cond_status |>\n  dplyr::select(\n    Model, sem_study, direction, rho,\n    n, T = any_of(\"T\"),   # <-- same here\n    param, mcmc_status,\n    N_valid,\n    mean_rel_bias, coverage_95, RMSE,\n    mean_post_sd, emp_sd, sd_bias\n  )\n\nreadr::write_csv(export_status, file.path(EXPORT_DIR, \"sem_analysis_status_split_core.csv\"))\n```\n:::\n\n\n\n\n# 7. Notes on interpretation\n\n* **Layer-specific copula:** ($\\rho$) is identified at the **active layer**. Fitting the “wrong” model (EI on EL data, or EL on EI data) can distort the PIT on that layer and bias ($\\hat{\\rho}$) toward zero (attenuation).\n* **One-sided support:** exponential margins imply hard bounds (e.g., right-skew requires ($e \\ge -s$)). Chains that frequently propose off-support values tend to report divergences; nevertheless, coverage for ($\\Phi$) and ($\\mu$) can remain adequate if mixing elsewhere is good.\n* **Scales:** both EI and EL estimate ($\\sigma_{\\exp}[j]$) with truth (=1); bias/coverage for these parameters help diagnose whether the model is matching the marginal one-sidedness.\n\n```\n\n**What this does for you**\n- Treats **`n := T` as the x-axis** in **every** panel (status, divergences, bias, coverage, SD-bias, sigma, and status-split).\n- The **design table** reads your actual grid and prints what’s present (so it’s correct for the 8-condition setup you posted).\n- Uses **your LaTeX style** ($\\cdot$) throughout.\n- Avoids the earlier `NULL` plots for $\\sigma_{\\exp}$ by using `plot_metric_any_n()` that does **not** filter to `core_params`.\n```\n",
    "supporting": [
      "study_5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}