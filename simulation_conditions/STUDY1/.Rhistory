# helper function for plotting metrics across conditions
plot_metric <- function(data, metric_col, ylab, title, use_free_y = FALSE, ylims = NULL) {
# filter out potential NAs (e.g. if N_truth_avail = 0)
data_filtered <- data |> filter(!is.na(.data[[metric_col]]))
if (nrow(data_filtered) == 0) {
message("Skipping plot '", title, "' due to missing data.")
return(NULL)
}
p <- ggplot(data_filtered, aes(x = T, y = .data[[metric_col]], color = Model, group = Model)) +
geom_line(position = position_dodge(dodge_width), linewidth = 1) +
geom_point(position = position_dodge(dodge_width), size = 2.5) +
# labeller = label_both correctly adds the variable name (VARset, rho) and the value.
facet_grid(param ~ direction + VARset + rho, labeller = label_both, scales = ifelse(use_free_y, "free_y", "fixed")) +
theme_standard +
labs(title = title, y = ylab, x = "Time Points (T)")
# add reference lines based on the metric
if (metric_col %in% c("mean_rel_bias", "sd_bias")) {
p <- p + geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey")
} else if (metric_col == "coverage_95") {
p <- p + geom_hline(yintercept = 0.95, linetype = "dashed", color = "darkgrey")
}
# apply custom Y-axis limits if provided
if (!is.null(ylims)) {
p <- p + coord_cartesian(ylim = ylims)
}
return(p)
}
# wrapper to filter data and call the plotting function for a specific skew level
generate_plots_for_condition <- function(skew_lvl) {
data_subset <- cond |>
filter(skew_level == skew_lvl, param %in% core_params)
# Adjust Y-axis limits for coverage based on the condition severity
cov_ylims <- if (skew_lvl == "extremeCHI") c(0.5, 1.0) else c(0.8, 1.0)
list(
# Metric: Relative Bias
bias = plot_metric(data_subset, "mean_rel_bias", "Mean Relative Bias",
paste("Relative Bias (DGP:", skew_lvl, ")"), use_free_y = TRUE),
# Metric: 95% CI Coverage
coverage = plot_metric(data_subset, "coverage_95", "Empirical Coverage",
paste("95% Coverage (DGP:", skew_lvl, ")"), ylims = cov_ylims),
# Metric: RMSE (Overall Accuracy)
rmse = plot_metric(data_subset, "RMSE", "Root Mean Squared Error",
paste("RMSE (DGP:", skew_lvl, ")"), use_free_y = TRUE),
# Metric: Posterior SD (Uncertainty Estimate)
post_sd = plot_metric(data_subset, "mean_post_sd", "Mean Posterior SD",
paste("Mean Posterior SD (DGP:", skew_lvl, ")"), use_free_y = TRUE),
# Metric: SD-Bias (Calibration of Uncertainty)
sdbias = plot_metric(data_subset, "sd_bias", "SD-Bias (Negative=Overconfident)",
paste("SD-Bias (DGP:", skew_lvl, ")"), use_free_y = TRUE)
)
}
#| label: moderateSN_plots
plots_mod <- generate_plots_for_condition("moderateSN")
#| label: moderateSN_bias
print(plots_mod$bias)
#| label: moderateSN_coverage
print(plots_mod$coverage)
#| label: moderateSN_sdbias
# Note: RMSE and Mean Posterior SD plots are omitted for brevity, focusing on Bias, Coverage, and SD-Bias.
print(plots_mod$sdbias)
#| label: strongSN_plots
plots_strong <- generate_plots_for_condition("strongSN")
#| label: strongSN_bias
print(plots_strong$bias)
#| label: strongSN_coverage
print(plots_strong$coverage)
#| label: strongSN_sdbias
print(plots_strong$sdbias)
#| label: extremeCHI_plots
plots_extreme <- generate_plots_for_condition("extremeCHI")
#| label: extremeCHI_bias
print(plots_extreme$bias)
#| label: extremeCHI_coverage
print(plots_extreme$coverage)
#| label: extremeCHI_sdbias
print(plots_extreme$sdbias)
#| label: ng_sigma_inflation
sigma_data <- cond |>
filter(param %in% c("sigma[1]", "sigma[2]"), Model == "Normal (NG)")
# We plot the absolute bias (mean_bias) here as the truth is 1.
ggplot(sigma_data, aes(x = T, y = mean_bias, color = skew_level, group = skew_level)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey") +
facet_grid(param ~ direction + VARset + rho, labeller = label_both) +
theme_standard +
labs(title = "NG Model: Bias for Sigma (Truth=1) - Variance Inflation/Deflation",
y = "Mean Bias (Estimate - 1)",
x = "Time Points (T)",
color = "DGP Skew Level")
#| label: sg_alpha_recovery
alpha_data <- cond |>
filter(param %in% c("alpha[1]", "alpha[2]"),
Model == "Skew-Normal (SG)",
skew_level %in% c("moderateSN", "strongSN"))
# Filter NAs in case truth was unavailable
alpha_data <- alpha_data |> filter(!is.na(mean_rel_bias))
if (nrow(alpha_data) > 0) {
ggplot(alpha_data, aes(x = T, y = mean_rel_bias, color = skew_level, group = skew_level)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey") +
ggh4x::facet_nested(param ~ direction + VARset + rho, labeller = label_both, scales = "free_y") +
theme_standard +
labs(title = "SG Model: Relative Bias for Alpha (Shape Parameter)",
y = "Relative Bias",
x = "Time Points (T)",
color = "DGP Skew Level")
}
#| label: reaggregate_by_status
# Helper function to re-aggregate metrics, filtering by MCMC status
# It is crucial to recalculate Empirical SD, SD-Bias, and RMSE within the subgroups.
aggregate_by_status <- function(df) {
df |>
# Filter out total failures
filter(mcmc_status != "Failed/Error") |>
group_by(condition_id, Model, param, mcmc_status, T, skew_level, direction, VARset, rho, VARset_val, rho_val) |>
summarise(
N_valid = n(),
mean_rel_bias = mean(rel_bias, na.rm = TRUE),
coverage_95 = mean(cover95, na.rm = TRUE),
# Recalculate components for SD-Bias and RMSE within the status group
mean_post_sd = mean(post_sd, na.rm = TRUE),
emp_sd = sd(post_mean, na.rm = TRUE),
mean_bias = mean(bias, na.rm=TRUE),
.groups = "drop"
) |>
mutate(
# Handle cases where N_valid=1, leading to NA emp_sd
emp_sd = ifelse(is.na(emp_sd), 0, emp_sd),
sd_bias = mean_post_sd - emp_sd,
RMSE = sqrt(mean_bias^2 + emp_sd^2)
)
}
cond_status <- aggregate_by_status(rep_df)
#| label: coverage_status_split
status_comparison_data <- cond_status |>
filter(Model == "Skew-Normal (SG)",
param %in% core_params)
# We focus the visualization on the interaction between T, Status, and Skew Level
# We average over VARset, rho, and direction for a clearer overview
status_overview <- status_comparison_data |>
group_by(T, param, skew_level, mcmc_status) |>
summarise(mean_coverage = mean(coverage_95, na.rm = TRUE), .groups = 'drop')
ggplot(status_overview,
aes(x = T, y = mean_coverage, color = mcmc_status, group = mcmc_status)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0.95, linetype = "dashed", color = "darkgrey") +
# Facet by parameter and skew level
facet_grid(param ~ skew_level) +
theme_standard +
labs(title = "SG Model Coverage: Clean vs. Problematic Runs Across Conditions",
y = "Average Empirical Coverage",
x = "Time Points (T)",
color = "MCMC Status") +
coord_cartesian(ylim = c(0.8, 1.0))
#| label: bias_vs_divergences
div_bias_data <- rep_df |>
filter(Model == "Skew-Normal (SG)",
skew_level == "strongSN",
param %in% core_params,
mcmc_status != "Failed/Error")
# Use absolute bias for comparison
ggplot(div_bias_data, aes(x = n_div, y = abs(bias))) +
geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 2) +
# Use a generalized additive model (gam) for smoothing to capture non-linear relationships
geom_smooth(method = "gam", color = "red", linewidth = 1.5) +
facet_grid(param ~ T, scales = "free") +
theme_standard +
labs(title = "Absolute Bias vs. Divergences (SG Model, strongSN)",
x = "Number of Divergent Transitions (n_div)",
y = "Absolute Bias")
#| label: export_tables
# 1. Main Condition-Level Summary (Aggregated across all successful runs)
# This table includes all metrics (Bias, Coverage, SD-Bias, RMSE, Posterior SD, Divergences)
# aggregated by condition, model, and parameter.
export_cond <- cond |>
# Select relevant columns and restore original factor values for clarity
select(condition_id, Model, param, skew_level, direction, T,
rho = rho_val, VARset = VARset_val,
N_valid, N_truth_avail,
mean_rel_bias, coverage_95, RMSE,
mean_post_sd, emp_sd, sd_bias,
mean_n_div, prop_div, mean_rhat)
write_csv(export_cond, file.path(EXPORT_DIR, "analysis_summary_aggregated.csv"))
# message("Exported aggregated summary to: ", file.path(EXPORT_DIR, "analysis_summary_aggregated.csv"))
# 2. Status-Split Summary (Aggregated within Clean/Problematic groups)
# This table allows for analyzing the impact of MCMC diagnostics on performance.
export_status <- cond_status |>
# Select relevant columns
select(condition_id, Model, param, mcmc_status,
skew_level, direction, T,
rho = rho_val, VARset = VARset_val,
N_valid,
mean_rel_bias, coverage_95, RMSE,
mean_post_sd, emp_sd, sd_bias)
write_csv(export_status, file.path(EXPORT_DIR, "analysis_summary_status_split.csv"))
# message("Exported status-split summary to: ", file.path(EXPORT_DIR, "analysis_summary_status_split.csv"))
# 3. MCMC Health Summary (Counts)
mcmc_health_export <- mcmc_summary |>
pivot_wider(names_from = mcmc_status, values_from = Count, values_fill = list(Count = 0)) |>
arrange(Model, skew_level, T)
write_csv(mcmc_health_export, file.path(EXPORT_DIR, "analysis_mcmc_health_counts.csv"))
# message("Exported MCMC health counts to: ", file.path(EXPORT_DIR, "analysis_mcmc_health_counts.csv"))
```{r ng_sigma_inflation, fig.height=12, fig.width=11}
#| label: ng_sigma_inflation
sigma_data <- cond |>
filter(param %in% c("sigma[1]", "sigma[2]"), Model == "Normal (NG)")
# We plot the absolute bias (mean_bias) here as the truth is 1.
ggplot(sigma_data, aes(x = T, y = mean_bias, color = skew_level, group = skew_level)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey") +
facet_grid(param ~ direction + VARset + rho, labeller = label_both) +
theme_standard +
labs(title = "NG Model: Bias for Sigma (Truth=1) - Variance Inflation/Deflation",
y = "Mean Bias (Estimate - 1)",
x = "Time Points (T)",
color = "DGP Skew Level")
#| label: ng_sigma_inflation
sigma_data <- cond |>
filter(param %in% c("sigma[1]", "sigma[2]"), Model == "Normal (NG)")
# We plot the absolute bias (mean_bias) here as the truth is 1.
ggplot(sigma_data, aes(x = T, y = mean_bias, color = skew_level, group = skew_level)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey") +
facet_grid(param ~ direction + VARset + rho, labeller = label_both) +
theme_standard +
labs(title = "NG Model: Bias for Sigma (Truth=1) - Variance Inflation/Deflation",
y = "Mean Bias (Estimate - 1)",
x = "Time Points (T)",
color = "DGP Skew Level")
#| label: sg_alpha_recovery
alpha_data <- cond |>
filter(param %in% c("alpha[1]", "alpha[2]"),
Model == "Skew-Normal (SG)",
skew_level %in% c("moderateSN", "strongSN"))
# Filter NAs in case truth was unavailable
alpha_data <- alpha_data |> filter(!is.na(mean_rel_bias))
if (nrow(alpha_data) > 0) {
ggplot(alpha_data, aes(x = T, y = mean_rel_bias, color = skew_level, group = skew_level)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey") +
ggh4x::facet_nested(param ~ direction + VARset + rho, labeller = label_both, scales = "free_y") +
theme_standard +
labs(title = "SG Model: Relative Bias for Alpha (Shape Parameter)",
y = "Relative Bias",
x = "Time Points (T)",
color = "DGP Skew Level")
}
#| label: reaggregate_by_status
# Helper function to re-aggregate metrics, filtering by MCMC status
# It is crucial to recalculate Empirical SD, SD-Bias, and RMSE within the subgroups.
aggregate_by_status <- function(df) {
df |>
# Filter out total failures
filter(mcmc_status != "Failed/Error") |>
group_by(condition_id, Model, param, mcmc_status, T, skew_level, direction, VARset, rho, VARset_val, rho_val) |>
summarise(
N_valid = n(),
mean_rel_bias = mean(rel_bias, na.rm = TRUE),
coverage_95 = mean(cover95, na.rm = TRUE),
# Recalculate components for SD-Bias and RMSE within the status group
mean_post_sd = mean(post_sd, na.rm = TRUE),
emp_sd = sd(post_mean, na.rm = TRUE),
mean_bias = mean(bias, na.rm=TRUE),
.groups = "drop"
) |>
mutate(
# Handle cases where N_valid=1, leading to NA emp_sd
emp_sd = ifelse(is.na(emp_sd), 0, emp_sd),
sd_bias = mean_post_sd - emp_sd,
RMSE = sqrt(mean_bias^2 + emp_sd^2)
)
}
cond_status <- aggregate_by_status(rep_df)
#| label: coverage_status_split
status_comparison_data <- cond_status |>
filter(Model == "Skew-Normal (SG)",
param %in% core_params)
# We focus the visualization on the interaction between T, Status, and Skew Level
# We average over VARset, rho, and direction for a clearer overview
status_overview <- status_comparison_data |>
group_by(T, param, skew_level, mcmc_status) |>
summarise(mean_coverage = mean(coverage_95, na.rm = TRUE), .groups = 'drop')
ggplot(status_overview,
aes(x = T, y = mean_coverage, color = mcmc_status, group = mcmc_status)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0.95, linetype = "dashed", color = "darkgrey") +
# Facet by parameter and skew level
facet_grid(param ~ skew_level) +
theme_standard +
labs(title = "SG Model Coverage: Clean vs. Problematic Runs Across Conditions",
y = "Average Empirical Coverage",
x = "Time Points (T)",
color = "MCMC Status") +
coord_cartesian(ylim = c(0.8, 1.0))
#| label: coverage_status_split
status_comparison_data <- cond_status |>
filter(Model == "Skew-Normal (SG)",
param %in% core_params)
# We focus the visualization on the interaction between T, Status, and Skew Level
# We average over VARset, rho, and direction for a clearer overview
status_overview <- status_comparison_data |>
group_by(T, param, skew_level, mcmc_status) |>
summarise(mean_coverage = mean(coverage_95, na.rm = TRUE), .groups = 'drop')
ggplot(status_overview,
aes(x = T, y = mean_coverage, color = mcmc_status, group = mcmc_status)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0.95, linetype = "dashed", color = "darkgrey") +
# Facet by parameter and skew level
facet_grid(param ~ skew_level) +
theme_standard +
labs(title = "SG Model Coverage: Clean vs. Problematic Runs Across Conditions",
y = "Average Empirical Coverage",
x = "Time Points (T)",
color = "MCMC Status") +
coord_cartesian(ylim = c(0.8, 1.0))
#| label: ng_sigma_inflation
sigma_data <- cond |>
filter(param %in% c("sigma[1]", "sigma[2]"), Model == "Normal (NG)")
# We plot the absolute bias (mean_bias) here as the truth is 1.
ggplot(sigma_data, aes(x = T, y = mean_bias, color = skew_level, group = skew_level)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "darkgrey") +
facet_grid(param ~ direction + VARset + rho, labeller = label_both) +
theme_standard +
labs(title = "NG Model: Bias for Sigma (Truth=1) - Variance Inflation/Deflation",
y = "Mean Bias (Estimate - 1)",
x = "Time Points (T)",
color = "DGP Skew Level")
#| label: reaggregate_by_status
# Helper function to re-aggregate metrics, filtering by MCMC status
# It is crucial to recalculate Empirical SD, SD-Bias, and RMSE within the subgroups.
aggregate_by_status <- function(df) {
df |>
# Filter out total failures
filter(mcmc_status != "Failed/Error") |>
group_by(condition_id, Model, param, mcmc_status, T, skew_level, direction, VARset, rho, VARset_val, rho_val) |>
summarise(
N_valid = n(),
mean_rel_bias = mean(rel_bias, na.rm = TRUE),
coverage_95 = mean(cover95, na.rm = TRUE),
# Recalculate components for SD-Bias and RMSE within the status group
mean_post_sd = mean(post_sd, na.rm = TRUE),
emp_sd = sd(post_mean, na.rm = TRUE),
mean_bias = mean(bias, na.rm=TRUE),
.groups = "drop"
) |>
mutate(
# Handle cases where N_valid=1, leading to NA emp_sd
emp_sd = ifelse(is.na(emp_sd), 0, emp_sd),
sd_bias = mean_post_sd - emp_sd,
RMSE = sqrt(mean_bias^2 + emp_sd^2)
)
}
cond_status <- aggregate_by_status(rep_df)
#| label: coverage_status_split
status_comparison_data <- cond_status |>
filter(Model == "Skew-Normal (SG)",
param %in% core_params)
# We focus the visualization on the interaction between T, Status, and Skew Level
# We average over VARset, rho, and direction for a clearer overview
status_overview <- status_comparison_data |>
group_by(T, param, skew_level, mcmc_status) |>
summarise(mean_coverage = mean(coverage_95, na.rm = TRUE), .groups = 'drop')
ggplot(status_overview,
aes(x = T, y = mean_coverage, color = mcmc_status, group = mcmc_status)) +
geom_line(position = position_dodge(0.3), linewidth = 1) +
geom_point(position = position_dodge(0.3), size = 2.5) +
geom_hline(yintercept = 0.95, linetype = "dashed", color = "darkgrey") +
# Facet by parameter and skew level
facet_grid(param ~ skew_level) +
theme_standard +
labs(title = "SG Model Coverage: Clean vs. Problematic Runs Across Conditions",
y = "Average Empirical Coverage",
x = "Time Points (T)",
color = "MCMC Status") +
coord_cartesian(ylim = c(0.8, 1.0))
#| label: bias_vs_divergences
div_bias_data <- rep_df |>
filter(Model == "Skew-Normal (SG)",
skew_level == "strongSN",
param %in% core_params,
mcmc_status != "Failed/Error")
# Use absolute bias for comparison
ggplot(div_bias_data, aes(x = n_div, y = abs(bias))) +
geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 2) +
# Use a generalized additive model (gam) for smoothing to capture non-linear relationships
geom_smooth(method = "gam", color = "red", linewidth = 1.5) +
facet_grid(param ~ T, scales = "free") +
theme_standard +
labs(title = "Absolute Bias vs. Divergences (SG Model, strongSN)",
x = "Number of Divergent Transitions (n_div)",
y = "Absolute Bias")
fit_EG_cond001_rep001 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond001_rep001.rds")
View(fit_EG_cond001_rep001)
fit_EG_cond003_rep071 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond003_rep071.rds")
View(fit_EG_cond003_rep071)
fit_EG_cond003_rep071
fit_EG_cond004_rep164 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond004_rep164.rds")
fit_EG_cond004_rep164
fit_EG_cond001_rep022 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond001_rep022.rds")
fit_EG_cond001_rep022
fit_EG_cond001_rep012 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond001_rep012.rds")
View(fit_EG_cond001_rep012)
fit_EG_cond009_rep091 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond009_rep091.rds")
fit_EG_cond009_rep091
View(fit_EG_cond009_rep091)
fit_EG_cond001_rep070 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond001_rep070.rds")
View(fit_EG_cond001_rep070)
fit_EG_cond007_rep049 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond007_rep049.rds")
fit_EG_cond007_rep049
sim_conditions <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/data/sim_conditions.rds")
sim_conditions
View(fit_EG_cond007_rep049)
View(sim_conditions)
fit_EG_cond006_rep159 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond006_rep159.rds")
fit_EG_cond006_rep159
View(fit_EG_cond006_rep159)
fit_NG_cond010_rep009 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_NG_cond010_rep009.rds")
fit_NG_cond010_rep009
View(fit_NG_cond010_rep009)
sim_conditions <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/data/sim_conditions.rds")
sim_conditions
View(sim_conditions)
fit_EG_cond001_rep008 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond001_rep008.rds")
fit_EG_cond001_rep008
fit_EG_cond012_rep156 <- readRDS("~/Documents/var_copula/simulation_conditions/STUDY2/fits/fit_EG_cond012_rep156.rds")
fit_EG_cond012_rep156
View(fit_EG_cond012_rep156)
View(sim_conditions)
View(sim_conditions[[8]][[33]])
#| label: setup
# load necessary libraries
suppressPackageStartupMessages({
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
library(stringr)
library(knitr)
library(RColorBrewer)
library(ggh4x)
library(sn)
})
# define paths
# BASE_DIR <- getwd() # needed for interactive running
DATA_DIR <- file.path("data")
RES_DIR <- file.path("results")
EXPORT_DIR <- file.path(RES_DIR, "exported_tables")
dir.create(EXPORT_DIR, showWarnings = FALSE, recursive = TRUE)
files <- list(
cond    = file.path(RES_DIR, "summary_conditions.csv"),
rep     = file.path(RES_DIR, "summary_replications.csv"),
design = file.path(DATA_DIR, "sim_conditions_singlelevel.rds")
)
if (!all(file.exists(unlist(files)))) {
stop("Missing required input files. Please ensure analysis_singlelevel.R has been run.")
}
# SN parameters that enforce mean 0 and var 1 for a given alpha
sn_params <- function(alpha) {
delta <- alpha / sqrt(1 + alpha^2)
omega <- sqrt(1 / (1 - 2 * delta^2 / pi))       # Var = 1
xi    <- -omega * delta * sqrt(2 / pi)          # Mean = 0
list(xi = xi, omega = omega, alpha = alpha)
}
set.seed(2025)
# standardized chi-square draws (df = 1), both right-skewed and mirrored
rchisq_std <- function(n, df = 1, mirror = FALSE) {
x  <- stats::rchisq(n, df = df)
z  <- (x - df) / sqrt(2 * df)  # mean 0, var 1
if (mirror) -z else z
}
# 20k draws per margin
draws <- list(
"SN  alpha = +4"              = sn::rsn(20000, xi = sn_params(+4)$xi, omega = sn_params(+4)$omega, alpha = +4),
"SN  alpha = -4"              = sn::rsn(20000, xi = sn_params(-4)$xi, omega = sn_params(-4)$omega, alpha = -4),
"SN  alpha = +9"              = sn::rsn(20000, xi = sn_params(+9)$xi, omega = sn_params(+9)$omega, alpha = +9),
"SN  alpha = -9"              = sn::rsn(20000, xi = sn_params(-9)$xi, omega = sn_params(-9)$omega, alpha = -9),
"χ² df=1 (std., right)"       = rchisq_std(20000, df = 1, mirror = FALSE),
"χ² df=1 (std., mirrored)"    = rchisq_std(20000, df = 1, mirror = TRUE)
)
df_m <- dplyr::bind_rows(lapply(names(draws), function(nm) {
tibble::tibble(value = draws[[nm]], dist = nm)
}))
# palette
pal <- c("SN  alpha = +4"           = "#1b9e77",
"SN  alpha = -4"           = "#1b9e77",
"SN  alpha = +9"           = "#d95f02",
"SN  alpha = -9"           = "#d95f02",
"χ² df=1 (std., right)"    = "#7570b3",
"χ² df=1 (std., mirrored)" = "#7570b3")
ggplot(df_m, aes(value)) +
geom_histogram(aes(y = after_stat(density), fill = dist),
bins = 60, alpha = 0.25, colour = NA) +
geom_density(aes(colour = dist), linewidth = 0.8) +
# N(0,1) reference
stat_function(fun = dnorm, linewidth = 0.7, linetype = "dashed") +
geom_vline(xintercept = 0, linetype = "dotted") +
scale_fill_manual(values = pal, guide = "none") +
scale_colour_manual(values = pal, name = "") +
facet_wrap(~ dist, scales = "free", ncol = 2) +
theme_bw(base_size = 10) +
labs(title = "Standardized marginal innovations used in the DGP",
x = "value", y = "density")
