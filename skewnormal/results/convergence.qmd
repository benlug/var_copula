---
title: "Convergence Diagnostics for Normal vs. Skew-Normal Model Fits"
subtitle: "Assessing MCMC Sampling Performance Across Conditions"
date: "`r format(Sys.time(), '%B %d, %Y')`"
execute:
  echo: true
  warning: false # Set TRUE for debugging
  message: true
  error: true # Show errors during execution
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 3
    number-sections: true
    theme: cosmo
    page-layout: full
---

```{r setup, include=FALSE}
# Libraries
library(rstan)
library(tidyverse)
# library(bayesplot) # No longer needed
# library(posterior) # Keep if needed for other summaries?
library(knitr)
library(kableExtra)
# library(gridExtra) # Removed
# library(grid) # Removed
library(forcats)
library(ggplot2) # Load explicitly
library(this.path)

# --- Define Paths Relative to this QMD File ---
RESULTS_DIR <- this.dir()
if (!dir.exists(RESULTS_DIR)) stop("Results directory not found:", RESULTS_DIR)
FITS_DIR <- file.path(RESULTS_DIR, "../fits")
DATA_DIR <- file.path(RESULTS_DIR, "../data")

# Use absolute paths for checking existence
fits_dir_abs <- normalizePath(FITS_DIR, mustWork = FALSE)
data_dir_abs <- normalizePath(DATA_DIR, mustWork = FALSE)

if (!dir.exists(fits_dir_abs)) stop("Fits directory not found: ", fits_dir_abs)
if (!dir.exists(data_dir_abs)) stop("Data directory not found: ", data_dir_abs)

# Stan/R options
rstan::rstan_options(auto_write = TRUE)
`%||%` <- function(a, b) if (!is.null(a)) a else b
options(mc.cores = parallel::detectCores() %||% 1)
theme_set(theme_bw(base_size = 11))

# --- Load Simulation Conditions (Still needed for reference/lookup) ---
sim_conds_file <- file.path(data_dir_abs, "sim_conditions.rds")
if (!file.exists(sim_conds_file)) stop("Cannot find sim conditions file: ", sim_conds_file)
sim_conditions_df <- readRDS(sim_conds_file) %>%
  # Select necessary columns for lookup and titles
  dplyr::select(condition_id, N, T, target_alpha, phi11_base, phi12_base, has_random_effects) %>%
  dplyr::distinct(condition_id, .keep_all = TRUE) %>%
  mutate(condition_id = as.integer(condition_id)) # Ensure type

# --- Load Parameter Recovery Results ---
# Needed for Rhat and N_eff
param_results_file <- file.path(RESULTS_DIR, "simulation_parameter_results_with_vars.rds")
if (!file.exists(param_results_file)) {
  stop(
    "Parameter results file not found: ", param_results_file,
    "\nPlease ensure process_fits.R ran successfully (needed for Rhat/Neff)."
  )
}
results_df <- readRDS(param_results_file) %>%
  mutate(condition_id = as.integer(condition_id)) # Ensure type

# --- Load Sampler Info ---
# Needed for Divergences, MaxDepth, E-FMI
sampler_info_file <- file.path(RESULTS_DIR, "sampler_information.rds")
if (!file.exists(sampler_info_file)) {
  warning("Sampler info file not found: ", sampler_info_file, ". Sampler diagnostic plots will be missing.")
  sampler_info_df <- data.frame()
} else {
  sampler_info_df <- readRDS(sampler_info_file) %>%
    mutate(condition_id = as.integer(condition_id)) # Ensure type
}

# --- Assign to working variables ---
results_joined_df <- results_df
sampler_joined_df <- sampler_info_df


# --- Prepare Factors ---
# Master parameter order (for consistency if needed, less critical here)
master_param_order <- c(
  "mu_global[1]", "mu_global[2]", "phi11_base", "phi12_base", "phi21_base", "phi22_base",
  "phi11", "phi12", "phi21", "phi22", "rho", "sigma_mu[1]", "sigma_mu[2]",
  "sigma_phi[1]", "sigma_phi[2]", "sigma_phi[3]", "sigma_phi[4]",
  "var_sigma_mu[1]", "var_sigma_mu[2]", "var_sigma_phi[1]", "var_sigma_phi[2]", "var_sigma_phi[3]", "var_sigma_phi[4]",
  "sigma[1]", "sigma[2]", "xi[1]", "xi[2]", "omega[1]", "omega[2]", "alpha[1]", "alpha[2]"
)
model_levels <- c("normal", "skewnormal")

if (nrow(results_joined_df) == 0 && nrow(sampler_joined_df) == 0) {
  warning("No results or sampler data found after loading. Cannot proceed with analysis.")
  param_levels <- character(0)
  can_analyze <- FALSE
} else {
  can_analyze <- TRUE

  if (nrow(results_joined_df) > 0) {
    # --- Check and Mutate Factors for results_joined_df ---
    required_cols_res <- c("N", "T", "target_alpha", "has_random_effects", "phi11_base", "phi12_base", "parameter", "model_type", "condition_id")
    missing_cols_res <- setdiff(required_cols_res, names(results_joined_df))
    if (length(missing_cols_res) > 0) stop("Missing required columns in results_joined_df: ", paste(missing_cols_res, collapse = ", "))

    actual_params_in_data <- unique(as.character(results_joined_df$parameter))
    param_levels <- intersect(master_param_order, actual_params_in_data)

    results_joined_df <- results_joined_df %>%
      filter(!is.na(parameter)) %>% # Drop rows with NA parameter early
      mutate(
        parameter = factor(parameter, levels = param_levels),
        model_type = factor(model_type, levels = model_levels),
        condition_id = factor(condition_id),
        N_fac = factor(N), # Use _fac suffix for factor versions
        T_fac = factor(T),
        target_alpha_cat = factor(paste0("Alpha=", target_alpha)),
        re_cat = factor(ifelse(has_random_effects, "RE=ML", "RE=SL")),
        AR_base_fac = factor(paste0("AR=", phi11_base)),
        CrossLag_base_fac = factor(paste0("Cross=", phi12_base))
      ) %>%
      mutate(parameter = fct_drop(parameter)) # Drop unused levels after filtering

    param_levels <- levels(results_joined_df$parameter) # Update based on actual levels
  } else {
    param_levels <- character(0)
    warning("Parameter results data frame (results_joined_df) is empty. Rhat/Neff plots will be missing.")
  }

  if (nrow(sampler_joined_df) > 0) {
    # --- Check and Mutate Factors for sampler_joined_df ---
    required_cols_samp <- c("N", "T", "target_alpha", "has_random_effects", "phi11_base", "phi12_base", "model_type", "condition_id")
    missing_cols_samp <- setdiff(required_cols_samp, names(sampler_joined_df))
    if (length(missing_cols_samp) > 0) {
      warning("Missing required columns in sampler_joined_df: ", paste(missing_cols_samp, collapse = ", "), ". Sampler processing might fail.")
      # Add missing columns as NA if needed
      for (col in missing_cols_samp) sampler_joined_df[[col]] <- NA
    }

    sampler_joined_df <- sampler_joined_df %>%
      mutate(
        model_type = factor(model_type, levels = model_levels),
        condition_id = factor(condition_id),
        # Ensure factors exist even if columns were potentially missing
        N_fac = factor(N),
        T_fac = factor(T),
        target_alpha_cat = factor(paste0("Alpha=", target_alpha)),
        re_cat = factor(ifelse(has_random_effects, "RE=ML", "RE=SL")),
        AR_base_fac = factor(paste0("AR=", phi11_base)),
        CrossLag_base_fac = factor(paste0("Cross=", phi12_base))
      )
  } else {
    warning("Sampler info data frame (sampler_joined_df) is empty. Sampler diagnostic plots will be missing.")
  }
}
```

# 1. Introduction {#sec-intro}

This document visualizes MCMC convergence diagnostics for the Normal and Skew-Normal multilevel VAR(1) model fits across the various conditions of the simulation study. We examine R-hat ($\hat{R}$), Effective Sample Size (ESS), divergent transitions, maximum treedepth hits, and E-BFMI. **Trace plots are omitted.**

# 2. Overall Sampler Diagnostics Summary {#sec-sampler-summary}

Summarizes key sampler issues across all replications *for each condition* and model type.

```{r sampler-summary-table, eval=can_analyze}
#| label: tbl-sampler-summary
#| tbl-cap: "Summary of Sampler Diagnostics per Simulation Condition"

if (exists("sampler_joined_df") && nrow(sampler_joined_df) > 0) {
  # Function to safely calculate summary stats
  safe_summarize <- function(x, fun, ...) {
    # Check if input is logical for mean calculation (like for pct)
    is_logical_input <- is.logical(x)
    x_finite <- x[is.finite(x)]
    if (length(x_finite) == 0) {
      # Return appropriate NA type
      return(if (is_logical_input) NA_real_ else ifelse(is.integer(x), NA_integer_, NA_real_))
    }
    # Ensure logicals are treated as numeric for mean
    if (is_logical_input && identical(fun, base::mean)) x_finite <- as.numeric(x_finite)
    # Handle edge case for max on potentially all-NA vector
    if (identical(fun, base::max) && all(is.na(x_finite))) {
      return(ifelse(is.integer(x), NA_integer_, NA_real_))
    }
    tryCatch(fun(x_finite, ...), error = function(e) ifelse(is.integer(x), NA_integer_, NA_real_))
  }

  sampler_summary <- sampler_joined_df %>%
    # Group by condition factors and model type using _fac versions
    group_by(condition_id, N_fac, T_fac, target_alpha_cat, re_cat, AR_base_fac, CrossLag_base_fac, model_type) %>%
    summarize(
      n_reps_fit = n(),
      # Use safe_summarize for all calculations
      n_reps_diverged = safe_summarize(divergences, function(x) sum(x > 0, na.rm = TRUE)),
      pct_reps_diverged = safe_summarize(divergences > 0, mean, na.rm = TRUE) * 100, # Pass logical vector directly
      avg_divergences = safe_summarize(divergences, mean, na.rm = TRUE),
      max_divergences = safe_summarize(divergences, max, na.rm = TRUE), # Handles potential -Inf from max({})
      n_reps_maxdepth = safe_summarize(maxdepth_exceeded, function(x) sum(x > 0, na.rm = TRUE)),
      pct_reps_maxdepth = safe_summarize(maxdepth_exceeded > 0, mean, na.rm = TRUE) * 100,
      avg_eFMI = safe_summarize(eFMI, mean, na.rm = TRUE),
      min_eFMI = safe_summarize(eFMI, min, na.rm = TRUE),
      n_reps_low_bfmi = safe_summarize(eFMI, function(x) sum(x < 0.3, na.rm = TRUE)),
      .groups = "drop"
    ) %>%
    # Replace potential Inf/-Inf that might still arise with NA
    mutate(across(where(is.numeric), ~ replace(., !is.finite(.), NA)))


  # Display table
  kable(sampler_summary,
    digits = 2, row.names = FALSE,
    caption = "Summary of Sampler Diagnostics per Simulation Condition"
  ) %>%
    kable_styling(bootstrap_options = c("striped", "condensed", "responsive"), font_size = 8) %>%
    scroll_box(width = "100%", height = "500px")
} else {
  cat("No sampler information data frame found or it is empty.")
}

```

# 3. Condition-Specific Diagnostic Plots {#sec-condition-plots}

Generates diagnostic plots for each simulation condition, combining information across replications. Each condition's section shows sampler diagnostics (Divergences, Max Depth, E-FMI) and parameter diagnostics (R-hat, N_eff distribution) as individual plots.

```{r define-plot-helpers, include=FALSE}
# --- Helper Functions for Plotting ---

# Function to generate condition title string (using condition factors)
get_condition_title <- function(cond_id_num, conditions_df) {
  # Find the row in the original conditions DF
  cond_info <- filter(conditions_df, condition_id == cond_id_num) %>% slice(1)
  if (nrow(cond_info) == 0) {
    return(paste("Condition", cond_id_num))
  }
  # Build title string
  sprintf(
    "Cond %d (N=%s, T=%s, Alpha=%.1f, RE=%s, AR=%.1f, Cross=%.1f)",
    cond_id_num,
    cond_info$N, cond_info$T, cond_info$target_alpha,
    ifelse(cond_info$has_random_effects, "ML", "SL"), # Use ML/SL
    cond_info$phi11_base, cond_info$phi12_base
  )
}
```

```{r diagnostic-plots-individual, fig.width=9, fig.height=5, results='asis', eval=can_analyze}
#| label: fig-diagnostic-plots-individual
#| fig-cap: "Convergence diagnostic plots for each simulation condition (shown individually)."
#| cache: false

# Get unique condition IDs that have *any* results (either sampler or parameter)
unique_cond_ids_present <- character(0)
if (exists("results_joined_df") && nrow(results_joined_df) > 0) {
  unique_cond_ids_present <- union(unique_cond_ids_present, unique(as.character(results_joined_df$condition_id)))
}
if (exists("sampler_joined_df") && nrow(sampler_joined_df) > 0) {
  unique_cond_ids_present <- union(unique_cond_ids_present, unique(as.character(sampler_joined_df$condition_id)))
}
unique_cond_ids_present <- sort(unique(unique_cond_ids_present))


if (length(unique_cond_ids_present) == 0) {
  cat("No conditions found with any results data to plot.\n")
} else {
  cat(paste("Generating individual diagnostic plots for", length(unique_cond_ids_present), "conditions...\n"))
}

# Loop through each condition ID present in the data
for (cond_id_char in unique_cond_ids_present) {
  cond_id_num <- as.integer(cond_id_char)

  # --- Get Condition Title ---
  condition_title <- get_condition_title(cond_id_num, sim_conditions_df)
  cat(paste("\n\n####", condition_title, "\n")) # Use cat() for markdown header

  # --- Filter data for the current condition ---
  sampler_subdf <- filter(sampler_joined_df, condition_id == cond_id_char)
  results_subdf <- filter(results_joined_df, condition_id == cond_id_char)

  # Check if *any* data exists for this condition
  has_sampler_data <- nrow(sampler_subdf) > 0
  has_results_data <- nrow(results_subdf) > 0 && length(param_levels) > 0

  if (!has_sampler_data && !has_results_data) {
    cat("\n*(No parameter results or sampler info found for this condition)*\n")
    cat("\n<!-- Page break -->\n\n")
    next
  }

  # --- Generate and Print Individual Plots ---
  fill_scale_viridis <- scale_fill_viridis_d(option = "plasma", end = 0.8, name = "Model")

  # 1. Divergences
  cat("\n\n**Divergences per Replication**\n")
  if (has_sampler_data) {
    # Ensure rep_i is numeric before converting to factor for plotting axis
    sampler_subdf_plot <- sampler_subdf %>% mutate(rep_fct = factor(as.numeric(rep_i)))
    p_div <- ggplot(sampler_subdf_plot, aes(x = rep_fct, y = divergences, fill = model_type)) +
      geom_col(position = position_dodge(width = 0.7), color = "grey50", width = 0.6, na.rm = TRUE) +
      fill_scale_viridis +
      labs(subtitle = NULL, x = "Replication", y = "Count") + # Remove subtitle
      theme_bw(base_size = 10) +
      theme(legend.position = "bottom", axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
    print(p_div)
  } else {
    cat("\n*(No sampler data)*\n")
  }

  # 2. Max Treedepth Hits
  cat("\n\n**Max Treedepth Hits per Replication**\n")
  if (has_sampler_data) {
    sampler_subdf_plot <- sampler_subdf %>% mutate(rep_fct = factor(as.numeric(rep_i)))
    p_max <- ggplot(sampler_subdf_plot, aes(x = rep_fct, y = maxdepth_exceeded, fill = model_type)) +
      geom_col(position = position_dodge(width = 0.7), color = "grey50", width = 0.6, na.rm = TRUE) +
      fill_scale_viridis +
      guides(fill = "none") + # Remove redundant legend
      labs(subtitle = NULL, x = "Replication", y = "Count") +
      theme_bw(base_size = 10) +
      theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
    print(p_max)
  } else {
    cat("\n*(No sampler data)*\n")
  }

  # 3. E-FMI
  cat("\n\n**E-FMI per Replication**\n")
  if (has_sampler_data) {
    sampler_subdf_plot <- sampler_subdf %>% mutate(rep_fct = factor(as.numeric(rep_i)))
    p_eFMI <- ggplot(sampler_subdf_plot, aes(x = rep_fct, y = eFMI, fill = model_type)) +
      geom_col(position = position_dodge(width = 0.7), color = "grey50", width = 0.6, na.rm = TRUE) +
      geom_hline(yintercept = 0.3, linetype = "dashed", color = "red") +
      fill_scale_viridis +
      guides(fill = "none") + # Remove redundant legend
      labs(subtitle = NULL, x = "Replication", y = "E-FMI") +
      theme_bw(base_size = 10) +
      theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
    print(p_eFMI)
  } else {
    cat("\n*(No sampler data)*\n")
  }

  # 4. Rhat Distribution
  cat("\n\n**Rhat Distribution by Parameter**\n")
  if (has_results_data) {
    results_subdf_plot <- results_subdf %>%
      filter(!is.na(parameter)) %>%
      mutate(parameter = factor(parameter, levels = param_levels)) # Ensure factor levels
    if (nrow(results_subdf_plot) > 0) {
      p_rhat <- ggplot(results_subdf_plot, aes(x = parameter, y = Rhat, fill = model_type)) +
        geom_boxplot(position = position_dodge(width = 0.85), outlier.shape = 19, outlier.alpha = 0.5, outlier.size = 0.5, alpha = 0.7, width = 0.6, na.rm = TRUE) +
        geom_hline(yintercept = 1.05, color = "red", linetype = "dashed") +
        scale_fill_viridis_d(option = "plasma", end = 0.8, guide = "none") +
        scale_x_discrete(drop = FALSE) + # Keep all parameters on axis
        labs(subtitle = NULL, x = NULL, y = "Rhat") +
        theme_bw(base_size = 10) +
        theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8))
      print(p_rhat)
    } else {
      cat("\n*(No parameters with results data)*\n")
    }
  } else {
    cat("\n*(No results data)*\n")
  }

  # 5. N_eff Distribution
  cat("\n\n**N_eff Distribution by Parameter**\n")
  if (has_results_data) {
    results_subdf_plot <- results_subdf %>%
      filter(!is.na(parameter)) %>%
      mutate(parameter = factor(parameter, levels = param_levels)) # Ensure factor levels
    if (nrow(results_subdf_plot) > 0) {
      p_neff <- ggplot(results_subdf_plot, aes(x = parameter, y = n_eff, fill = model_type)) +
        geom_boxplot(position = position_dodge(width = 0.85), outlier.shape = 19, outlier.alpha = 0.5, outlier.size = 0.5, alpha = 0.7, width = 0.6, na.rm = TRUE) +
        scale_fill_viridis_d(option = "plasma", end = 0.8, guide = "none") +
        scale_x_discrete(drop = FALSE) + # Keep all parameters on axis
        labs(subtitle = NULL, x = NULL, y = "n_eff (log scale)") +
        # Use pseudo_log transform if zeros/negatives might occur, or ensure only positive n_eff
        scale_y_log10(limits = c(1, NA), oob = scales::squish, breaks = scales::log_breaks(n = 5)) +
        annotation_logticks(sides = "l", short = unit(0.1, "cm"), mid = unit(0.2, "cm"), long = unit(0.3, "cm")) +
        theme_bw(base_size = 10) +
        theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8))
      print(p_neff)
    } else {
      cat("\n*(No parameters with results data)*\n")
    }
  } else {
    cat("\n*(No results data)*\n")
  }

  # Add page break after each condition's set of plots
  cat("\n<!-- Page break -->\n\n")
} # End loop over conditions

# Final check if loop ran
if (length(unique_cond_ids_present) == 0) {
  plot(1, type = "n", axes = FALSE, xlab = "", ylab = "") # Placeholder plot
  title(main = "No results found to generate diagnostic plots.")
}

```