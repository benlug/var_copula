# investigate_failed_fits.R
# Utility script to inspect fit files that failed during processing.
# Reads 'failed_fit_report.csv' generated by process_fits.R and
# attempts to diagnose common issues.

library(tidyverse)
library(this.path)

RESULTS_DIR <- tryCatch(this.dir(), error = function(e) getwd())
FITS_DIR <- file.path(RESULTS_DIR, "../fits")

report_file <- file.path(RESULTS_DIR, "failed_fit_report.csv")
if (!file.exists(report_file)) {
  stop("Failure report not found: ", report_file)
}
failed_df <- read.csv(report_file, stringsAsFactors = FALSE)
if (nrow(failed_df) == 0) {
  cat("No failed fits recorded.\n")
  quit(save = "no")
}

inspect_failed_fit <- function(row) {
  # `row` is expected to be a named list with the elements from
  # `failed_fit_report.csv` for a single failed fit.
  fp <- file.path(FITS_DIR, row$file)
  info <- file.info(fp)
  exists <- !is.na(info$size)
  size <- if (exists) info$size else NA_integer_
  read_err <- NA_character_
  if (exists) {
    tryCatch({
      readRDS(fp)
    }, error = function(e) {
      read_err <- e$message
    })
  }
  tibble(
    file = row$file,
    reason_recorded = row$reason,
    file_exists = exists,
    file_size = size,
    read_error = read_err
  )
}

# `purrr::pmap_dfr` iterates over the rows of the data frame, passing
# each column value as a separate argument.  We wrap those values into a
# list so that `inspect_failed_fit()` receives a single `row` argument.
results <- purrr::pmap_dfr(
  failed_df,
  function(file, condition_id, rep_i, reason, file_size) {
    inspect_failed_fit(list(
      file = file,
      condition_id = condition_id,
      rep_i = rep_i,
      reason = reason,
      file_size = file_size
    ))
  }
)

print(results)
